---
uuid: 1a90fa40-56f1-11ee-94bb-cf1141f9218f
title: Mysql如何实现乐观锁
tags:
  - 乐观锁
  - 版本号机制
  - 时间戳机制
  - 并发控制
  - 数据冲突
  - 并发更新
  - 数据库
  - MySQL
  - 数据表
  - 版本号字段
  - 时间戳字段
  - 比较
  - 更新操作
  - 重试机制
  - 回滚操作
  - 性能
categories: []
abbrlink: d561c136
date: 2023-09-19 21:33:22
---


> 有的时候博客内容会有变动，首发博客是最新的，其他博客地址可能会未同步,认准`https://blog.zysicyj.top`

> 全网最细面试题手册，支持艾宾浩斯记忆法。这是一份最全面、最详细、最高质量的 java
面试题，不建议你死记硬背，只要每天复习一遍，有个大概印象就行了。 `https://store.amazingmemo.com/chapterDetail/1685324709017001`
    




---
在MySQL中，可以通过使用乐观锁来实现并发控制，以避免数据冲突和并发更新问题。乐观锁是一种乐观的思想，它假设并发操作不会导致冲突，只有在提交更新时才会检查是否发生冲突。

下面介绍两种常见的实现乐观锁的方式：

1. 版本号（Version）机制：
   - 在数据表中添加一个版本号字段，通常是一个整数类型。
   - 当读取数据时，将版本号一同读取出来。
   - 在更新数据时，先检查当前读取的版本号是否与数据库中的版本号一致，如果一致则进行更新操作，并将版本号加1；如果不一致，则表示数据已经被其他事务修改，需要进行相应的处理（例如回滚或者重新尝试）。
   - 通过版本号的比较，可以判断数据是否被其他事务修改过，从而实现乐观锁的效果。

   示例代码如下（使用Java语言）：

   ``` java
   // 读取数据
   String sql = "SELECT id, name, version FROM table_name WHERE id = ?";
   PreparedStatement pstmt = connection.prepareStatement(sql);
   pstmt.setInt(1, id);
   ResultSet rs = pstmt.executeQuery();
   if (rs.next()) {
       int version = rs.getInt("version");
       // 更新数据
       String updateSql = "UPDATE table_name SET name = ?, version = ? WHERE id = ? AND version = ?";
       PreparedStatement updateStmt = connection.prepareStatement(updateSql);
       updateStmt.setString(1, newName);
       updateStmt.setInt(2, version + 1);
       updateStmt.setInt(3, id);
       updateStmt.setInt(4, version);
       int affectedRows = updateStmt.executeUpdate();
       if (affectedRows == 0) {
           // 更新失败，数据已被其他事务修改
           // 进行相应的处理
       }
   }
   ```

2. 时间戳（Timestamp）机制：
   - 在数据表中添加一个时间戳字段，通常是一个时间类型（如DATETIME或TIMESTAMP）。
   - 当读取数据时，将时间戳一同读取出来。
   - 在更新数据时，先检查当前读取的时间戳是否与数据库中的时间戳一致，如果一致则进行更新操作；如果不一致，则表示数据已经被其他事务修改，需要进行相应的处理。
   - 通过时间戳的比较，可以判断数据是否被其他事务修改过，从而实现乐观锁的效果。

   示例代码如下（使用Java语言）：

   ``` java
   // 读取数据
   String sql = "SELECT id, name, timestamp FROM table_name WHERE id = ?";
   PreparedStatement pstmt = connection.prepareStatement(sql);
   pstmt.setInt(1, id);
   ResultSet rs = pstmt.executeQuery();
   if (rs.next()) {
       Timestamp timestamp = rs.getTimestamp("timestamp");
       // 更新数据
       String updateSql = "UPDATE table_name SET name = ?, timestamp = ? WHERE id = ? AND timestamp = ?";
       PreparedStatement updateStmt = connection.prepareStatement(updateSql);
       updateStmt.setString(1, newName);
       updateStmt.setTimestamp(2, newTimestamp);
       updateStmt.setInt(3, id);
       updateStmt.setTimestamp(4, timestamp);
       int affectedRows = updateStmt.executeUpdate();
       if (affectedRows == 0) {
           // 更新失败，数据已被其他事务修改
           // 进行相应的处理
       }
   }
   ```

需要注意的是，乐观锁并不能完全解决并发冲突的问题，它只是一种减少冲突概率的机制。在使用乐观锁时，需要注意处理并发冲突的情况，例如通过重试机制或者回滚操作来处理更新失败的情况。此外，乐观锁适用于并发读多写少的场景，如果并发写操作较多，可能会导致大量的重试和回滚操作，影响性能。

