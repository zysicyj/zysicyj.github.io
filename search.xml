<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Butterfly 安装文档(一) 快速开始</title>
      <link href="/2023/08/07/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
      <url>/2023/08/07/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在你的Hexo根目录里面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><h2 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h2><p>修改 Hexo 根目录下的 _config.yml，把主题改为 butterfly</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>如果你没有 pug 以及 stylus 的渲染器，请下载安装：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo<span class="literal">-renderer-pug</span> hexo<span class="literal">-renderer-stylus</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure><h2 id="升级建议"><a href="#升级建议" class="headerlink" title="升级建议"></a>升级建议</h2><blockquote><p>升级完成后，请到 Github 的 Releases 界面 或者 文档七 查看新版的更新内容。</p><p>里面有标注 _config 文件的变更内容（如有），请根据实际情况更新你的配置内容。</p></blockquote><p>为了减少升级主题后带来的不便，请使用以下方法（建议，可以不做）。</p><p>在 hexo 的根目录创建一个文件 _config.butterfly.yml，并把主题目录的 _config.yml 内容复制到 _config.butterfly.yml 去。( 注意: 复制的是主题的 _config.yml ，而不是 hexo 的 _config.yml)</p><blockquote><p>注意： 不要把主题目录的 _config.yml 删掉</p></blockquote><blockquote><p>注意： 以后只需要在 _config.butterfly.yml 进行配置就行。<br>        如果使用了 _config.butterfly.yml， 配置主题的 _config.yml 将不会有效果。</p></blockquote><p>Hexo会自动合併主题中的 _config.yml 和 _config.butterfly.yml 里的配置，如果存在同名配置，会使用 _config.butterfly.yml 的配置，其优先度较高。</p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072043458.png" alt="image-20200805191531090"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Butterfly </tag>
            
            <tag> 安装文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>配置Picgo图床之COS、OSS、Github图床</title>
      <link href="/2023/08/07/%E9%85%8D%E7%BD%AEPicgo%E5%9B%BE%E5%BA%8A%E4%B9%8BCOS%E3%80%81OSS%E3%80%81Github%E5%9B%BE%E5%BA%8A/"/>
      <url>/2023/08/07/%E9%85%8D%E7%BD%AEPicgo%E5%9B%BE%E5%BA%8A%E4%B9%8BCOS%E3%80%81OSS%E3%80%81Github%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PicGo是一款开源的图片上传和管理工具，它提供了简单易用的界面和丰富的功能，方便用户上传、管理和分享图片。</p><p>以下是PicGo的一些主要特点和功能：</p><ol><li><p>图片上传：PicGo支持将本地图片快速上传到云存储服务，如七牛云、腾讯云、阿里云等。你可以选择自己喜欢的云存储服务，并通过PicGo将图片批量上传到云端。</p></li><li><p>图片压缩：PicGo内置了图片压缩功能，可以帮助你在上传图片之前对图片进行压缩，减小图片文件大小，提高网页加载速度。</p></li><li><p>图片编辑：PicGo提供了简单的图片编辑功能，包括裁剪、旋转、调整亮度、对比度等。你可以在上传图片之前对图片进行一些基本的编辑操作。</p></li><li><p>图片管理：PicGo可以帮助你管理上传的图片，包括查看上传记录、复制图片链接、删除图片等。你可以方便地管理自己上传的图片，并在需要时获取图片链接进行分享。</p></li><li><p>自定义配置：PicGo支持自定义配置，你可以根据自己的需求设置上传的命名规则、存储路径、图片样式等。这样可以更好地满足个性化的需求。</p></li></ol><p>总的来说，PicGo是一款功能强大且易于使用的图片上传和管理工具，适用于个人用户、开发者和博主等多种场景。它可以帮助你更高效地上传、管理和分享图片。</p><h2 id="准备PicGo"><a href="#准备PicGo" class="headerlink" title="准备PicGo"></a>准备PicGo</h2><p>官网下载地址：<a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a></p><p>关注【程序员朱永胜】回复【1012】获取安装包，免费高速下载</p><h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><h3 id="获取Token"><a href="#获取Token" class="headerlink" title="获取Token"></a>获取Token</h3><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072004107.png" alt="image-20230807200430847"></p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072005596.png"></p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072005838.png"></p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>随便创建一个仓库即可，我创建的是<code>pic</code>仓库</p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072007898.png" alt="image-20230807200705649"></p><h3 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h3><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072007590.png"></p><h2 id="配置腾讯云COS"><a href="#配置腾讯云COS" class="headerlink" title="配置腾讯云COS"></a>配置腾讯云COS</h2><h3 id="获取Token-1"><a href="#获取Token-1" class="headerlink" title="获取Token"></a>获取Token</h3><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072008733.png" alt="image-20230807200848497"></p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072009686.png" alt="image-20230807200924438"></p><h3 id="创建存储桶"><a href="#创建存储桶" class="headerlink" title="创建存储桶"></a>创建存储桶</h3><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072010800.png"></p><p>设置为公有读私有写</p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072011353.png" alt="image-20230807201130106"></p><p>参考下面模版填写</p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072011921.png" alt="image-20230807201157858"></p><h2 id="设置阿里云OSS"><a href="#设置阿里云OSS" class="headerlink" title="设置阿里云OSS"></a>设置阿里云OSS</h2><h3 id="获取密钥"><a href="#获取密钥" class="headerlink" title="获取密钥"></a>获取密钥</h3><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072013528.png" alt="image-20230807201312297"></p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072013156.png" alt="image-20230807201333924"></p><h3 id="创建Bucket"><a href="#创建Bucket" class="headerlink" title="创建Bucket"></a>创建Bucket</h3><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072014937.png" alt="image-20230807201403715"></p><h3 id="参考下面模版"><a href="#参考下面模版" class="headerlink" title="参考下面模版"></a>参考下面模版</h3><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072014966.png" alt="image-20230807201422903"></p><p><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072015802.png" alt="image-20230807201500562"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PicGo </tag>
            
            <tag> 图床 </tag>
            
            <tag> Github </tag>
            
            <tag> COS </tag>
            
            <tag> OSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jrebel与Xrebel激活</title>
      <link href="/2023/08/06/Jrebel%E4%B8%8EXrebel%E6%BF%80%E6%B4%BB/"/>
      <url>/2023/08/06/Jrebel%E4%B8%8EXrebel%E6%BF%80%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JRebel和XRebel是两个非常有用的工具，可以显著提升Java开发人员的生产力和应用程序性能。</p><p>JRebel是一个强大的Java开发工具，它允许开发人员在不重新启动应用程序的情况下进行代码修改和调试。传统上，每次修改Java代码都需要重新编译和重新启动应用程序，这会浪费大量的时间。但是，使用JRebel，你可以即时看到你的代码修改的效果，无需重新启动应用程序。这种即时反馈的能力极大地提高了开发效率，缩短了开发周期。</p><p>JRebel通过在运行时重新加载修改的类文件，使得代码修改能够立即生效。它支持各种Java框架和服务器，包括Spring、Hibernate、Tomcat等。此外，JRebel还提供了与常见IDE（如Eclipse、IntelliJ IDEA）的集成，使得使用JRebel变得更加方便。</p><p>XRebel是另一个强大的工具，专注于Java应用程序的性能监控和优化。它可以实时监测和分析应用程序的性能瓶颈，帮助开发人员快速定位和解决性能问题。XRebel提供了一个直观的用户界面，显示了应用程序的请求和响应时间、数据库查询、HTTP会话等关键指标。它还能够检测潜在的性能问题，如慢查询、内存泄漏等，并提供相应的建议和解决方案。</p><p>XRebel支持各种Java应用程序，包括Web应用程序、企业应用程序等。它可以与常见的Java开发工具和服务器集成，如Eclipse、IntelliJ IDEA、Tomcat等。</p><p>综上所述，JRebel和XRebel是两个非常有用的工具，可以极大地提升Java开发人员的生产力和应用程序性能。JRebel允许即时查看代码修改的效果，而XRebel帮助开发人员实时监测和优化应用程序的性能。这两个工具的结合将为你的Java开发带来更高效和优化的体验。</p><h2 id="下载代理软件"><a href="#下载代理软件" class="headerlink" title="下载代理软件"></a>下载代理软件</h2><p>请关注某绿色软件【程序员朱永胜】回复<code>1011</code>获取</p><h2 id="双击打开"><a href="#双击打开" class="headerlink" title="双击打开"></a>双击打开</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308072033983.png" alt="image-20230806204843304"></h2><h2 id="获取UUID"><a href="#获取UUID" class="headerlink" title="获取UUID"></a>获取UUID</h2><p>打开<a href="https://www.guidgen.com/%EF%BC%8C%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AAUUID">https://www.guidgen.com/，生成一个UUID</a></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308062049509.png" alt="image-20230806204943298"></p><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>拷贝UUID到这里即可激活</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308062051024.png" alt="image-20230806205133975"></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308062052295.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> JRebel </tag>
            
            <tag> XRebel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IntelliJ IDEA 2023.2 最新变化</title>
      <link href="/2023/08/05/%E6%9C%80%E6%96%B0%E5%8F%98%E5%8C%96/"/>
      <url>/2023/08/05/%E6%9C%80%E6%96%B0%E5%8F%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>IntelliJ IDEA 2023.2 引入 AI Assistant，通过一组由 AI 提供支持的功能助力开发。 升级的 IntelliJ 分析器现在提供编辑器内提示，使分析进程更加直观详尽。 此版本还包括有助于简化开发工作流的 GitLab 集成，以及其他多项值得关注的更新和改进，如下所述：</p><h1 id="主要更新"><a href="#主要更新" class="headerlink" title="主要更新"></a>主要更新</h1><p> <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959533.png">  </p><h3 id="AI-Assistant"><a href="#AI-Assistant" class="headerlink" title="AI Assistant"></a>AI Assistant</h3><p>限定访问 Ultimate 在此版本中，我们为 IntelliJ IDEA 引入了一项重要补充 – AI Assistant。 AI Assistant 当前具备一组由 AI 提供支持的初始功能，提供集成式 AI 聊天，可以完成一些任务，例如自动编写文档注释、建议名称、生成提交消息等。 JetBrains AI 服务为 AI Assistant 提供技术支持，此服务目前可以连接到 OpenAI，后续还将包含其他语言模型提供商。 要访问 Assistant 的 AI 功能，您需要安装 AI Assistant 插件并使用 JetBrains Account 登录 JetBrains AI 服务。 JetBrains AI 服务的初始可用性可能受限。 有关 AI Assistant 的更多信息以及访问说明，请查阅<a href="https://blog.jetbrains.com/idea/2023/06/ai-assistant-in-jetbrains-ides/">这篇博文</a>。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959642.png"></p><h3 id="编辑器内性能提示"><a href="#编辑器内性能提示" class="headerlink" title="编辑器内性能提示"></a>编辑器内性能提示</h3><p>Ultimate 在 IntelliJ IDEA 2023.2 中，我们增强了 IntelliJ 分析器，为应用程序性能提供更有价值且易于理解的洞察。 新的编辑器内提示可供快速逐行分析代码性能，帮助您更快识别和解决问题。 编辑器装订区域中的颜色编码注解可以高亮显示关键方法，让您专注于性能瓶颈。 因此，您不再需要使用 _Flame Graph_（火焰图）和 _Call Tree_（调用树）视图执行彻底、耗时的分析。 在这篇<a href="https://blog.jetbrains.com/idea/2023/05/intellij-idea-2023-2-eap/#In-editorperformancehints">博文</a>中了解详情。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959607.png"> </p><h3 id="GitLab-集成"><a href="#GitLab-集成" class="headerlink" title="GitLab 集成"></a>GitLab 集成</h3><p> IntelliJ IDEA 2023.2 引入了与 GitLab 的集成，帮助简化您的开发工作流。 现在，您可以直接在 IDE 中使用 _Merge Requests_（合并请求）功能：查看请求列表、检查更改、留下评论，以及导航到相关视图。 <a href="https://blog.jetbrains.com/2023/07/25/gitlab-support-in-jetbrains-ides/">了解详情</a>。 </p><h1 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959553.png"> </p><h3 id="Search-Everywhere-（随处搜索）中的文本搜索"><a href="#Search-Everywhere-（随处搜索）中的文本搜索" class="headerlink" title="Search Everywhere_（随处搜索）中的文本搜索"></a>Search Everywhere_（随处搜索）中的文本搜索</h3><p>Search Everywhere_（随处搜索）（按两次 Shift）主要用于搜索文件、类、方法、操作和设置。 在此更新后，它将包含类似于 _Find in Files_（在文件中查找）的文本搜索功能。 现在，当给定查询的其他搜索结果很少或没有时，将显示文本搜索结果。 此功能默认启用，可以在 _Settings&#x2F;Preferences | Advanced Settings | Search Everywhere_（设置&#x2F;偏好设置 | 高级设置 | 随处搜索）中管理。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959581.png"> </p><h3 id="新-UI-中的彩色项目标题"><a href="#新-UI-中的彩色项目标题" class="headerlink" title="新 UI 中的彩色项目标题"></a>新 UI 中的彩色项目标题</h3><p>IntelliJ IDEA 2023.2 引入了彩色标题，可以简化多个打开的项目之间的导航。 现在，您可以为每个项目分配唯一的颜色和图标，使其在工作区中更易区分。 标题现在默认带有预定义的颜色，但您也可以自定义。 要为项目设置新的颜色，首先右键点击标题，然后访问上下文菜单。 然后，选择 _Change Project Color_（更改项目颜色）选项，并从建议的列表中选择所需颜色，或者浏览调色盘。 如果您想禁用此功能，只需在上下文菜单中取消选择 _Show Project Gradient_（显示项目渐变）选项。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959569.png"> </p><h3 id="在-Windows-和-Linux-上的主工具栏中重做了汉堡包菜单"><a href="#在-Windows-和-Linux-上的主工具栏中重做了汉堡包菜单" class="headerlink" title="在 Windows 和 Linux 上的主工具栏中重做了汉堡包菜单"></a>在 Windows 和 Linux 上的主工具栏中重做了汉堡包菜单</h3><p>我们改进了 Windows 和 Linux 上新 UI 中主工具栏汉堡包菜单的行为。 点击菜单图标后，元素现在水平显示在工具栏上方。 此外，现在还有一个选项可以将此菜单转换为单独的工具栏，此选项的路径为 _View | Appearance | Main menu as a Separate Toolbar_（视图 | 外观 | 主菜单作为单独的工具栏）。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959104.png"> </p><h3 id="在-Project-（项目）视图中按修改时间对文件进行排序"><a href="#在-Project-（项目）视图中按修改时间对文件进行排序" class="headerlink" title="在 _Project_（项目）视图中按修改时间对文件进行排序"></a>在 _Project_（项目）视图中按修改时间对文件进行排序</h3><p>IntelliJ IDEA 2023.2 添加了备受期待的功能，让您可以根据修改时间在 _Project_（项目）视图中排列文件。 每当项目中有更改被保存时，这个新功能就会自动重排文件。 要启用此功能，首先打开 _Project_（项目）视图中的竖三点菜单，然后选择 _Tree Appearance | Sort by Modification Time_（树外观 | 按修改时间排序）。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959174.png"> </p><h3 id="新-UI-中带有浅色标题的浅色主题"><a href="#新-UI-中带有浅色标题的浅色主题" class="headerlink" title="新 UI 中带有浅色标题的浅色主题"></a>新 UI 中带有浅色标题的浅色主题</h3><p>在 v2023.2 中，我们通过引入替代的 _Light with Light Header_（带有浅色标题的浅色主题）选项提升了_浅色_主题的用户体验，该选项可为窗口标题、工具提示和通知气球提供匹配的浅色。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959161.png"> </p><h3 id="更新了-macOS-上的窗口控件"><a href="#更新了-macOS-上的窗口控件" class="headerlink" title="更新了 macOS 上的窗口控件"></a>更新了 macOS 上的窗口控件</h3><p>在 macOS 上以全屏模式使用新 UI 时，窗口控件现在将在主工具栏上显示，而不是像以前一样在浮动栏上显示。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959213.png"> </p><h3 id="在新-UI-中移除了-Linux-上的标题栏"><a href="#在新-UI-中移除了-Linux-上的标题栏" class="headerlink" title="在新 UI 中移除了 Linux 上的标题栏"></a>在新 UI 中移除了 Linux 上的标题栏</h3><p>为了方便 Linux 用户，新 UI 中移除了操作系统的原生标题，使界面更加整洁。 默认将显示 IDE 的自定义标题，该标题提供了一系列工作区自定义选项。 如果您希望将标题还原为之前的外观，请取消选择 _Settings | Appearance &amp; Behavior | Appearance | UI Options_（设置 | 外观与行为 | 外观 | UI 选项）中的 <em>Merge main menu with window title</em> （将主菜单与窗口标题合并）选项。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959154.png"></p><h3 id="检查描述中的语法高亮显示"><a href="#检查描述中的语法高亮显示" class="headerlink" title="检查描述中的语法高亮显示"></a>检查描述中的语法高亮显示</h3><p>在 _Settings &#x2F; Preferences | Editor | Inspections_（设置&#x2F;偏好设置 | 编辑器 | 检查）中，代码示例现在将包含语法高亮显示，让您可以更容易理解是什么触发了检查并决定使其处于活跃状态还是停用状态。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959183.png"> </p><h3 id="在项目目录之间单击导航"><a href="#在项目目录之间单击导航" class="headerlink" title="在项目目录之间单击导航"></a>在项目目录之间单击导航</h3><p>在 _Project_（项目）视图中，新增了 _Open Directories with Single Click_（单击打开目录）选项，可以更快展开和收起项目文件夹，更快响应。 点击竖三点菜单后，可以从下拉菜单中选择该选项。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959630.png"> </p><h3 id="改进了主工具栏自定义"><a href="#改进了主工具栏自定义" class="headerlink" title="改进了主工具栏自定义"></a>改进了主工具栏自定义</h3><p>我们扩展了新 UI 主工具栏的自定义选项。 现在，您可以使用下拉菜单快速选择要添加到工具栏的操作。 右键点击任意微件，选择 _Add to Main Toolbar_（添加到主工具栏），然后浏览可用选项。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959584.png"> </p><h3 id="Settings-Preferences-（设置-偏好设置）中的推荐插件"><a href="#Settings-Preferences-（设置-偏好设置）中的推荐插件" class="headerlink" title="Settings&#x2F;Preferences_（设置&#x2F;偏好设置）中的推荐插件"></a>Settings&#x2F;Preferences_（设置&#x2F;偏好设置）中的推荐插件</h3><p>为了让您可以更轻松地为特定项目配置 IDE 以及通过插件扩展其功能，我们更新了 _Settings&#x2F;Preferences | Plugins_（设置&#x2F;偏好设置 | 插件）部分的 UI。 它现在包含一组推荐插件，根据您的项目具体情况自动定义，并在列表顶部显示。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959577.png"> </p><h3 id="更新了Services（服务）工具窗口中-Run-Debug-（运行-调试）"><a href="#更新了Services（服务）工具窗口中-Run-Debug-（运行-调试）" class="headerlink" title="更新了Services（服务）工具窗口中 _Run&#x2F;Debug_（运行&#x2F;调试）"></a>更新了Services（服务）工具窗口中 _Run&#x2F;Debug_（运行&#x2F;调试）</h3><p>微件的 UI 我们重做了 _Services_（服务）工具窗口中运行和调试操作的 UI，使工具栏外观与主 _Run&#x2F;Debug_（运行&#x2F;调试）微件一致。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959619.png"> </p><h3 id="在-Run-（运行）微件中固定运行配置"><a href="#在-Run-（运行）微件中固定运行配置" class="headerlink" title="在 _Run_（运行）微件中固定运行配置"></a>在 _Run_（运行）微件中固定运行配置</h3><p>为了简化多个运行配置的管理，我们在 _Run_（运行）微件中实现了固定首选配置的选项。 要将运行配置添加到 _Pinned_（固定）部分，首先打开其名称旁边的竖三点菜单，然后选择 _Pin_（固定）。 如果有多个固定的配置，在列表中拖放即可轻松排列。<br>#Java </p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959626.png"> </p><h3 id="新检查和其他代码分析改进"><a href="#新检查和其他代码分析改进" class="headerlink" title="新检查和其他代码分析改进"></a>新检查和其他代码分析改进</h3><p>我们改进并扩展了 Java 检查，帮助您维护优质代码并更有效地检测潜在问题。 当模式引用与实参不匹配时，新的 _Incorrect ‘MessageFormat’ pattern_（’MessageFormat’ 模式不正确）检查会发出警告，并且它还会检测 <code>MessageFormat</code> 模式中引号和大括号的错误用法。 此外，IDE 现在将报告带有显式 <code>ChronoField</code> 或 <code>ChronoUnit</code> 实参的调用，并建议将其替换为更具体的方法的调用，从而简化代码。 在这篇<a href="https://blog.jetbrains.com/idea/2023/05/intellij-idea-2023-2-eap-2/#Newinspectionsandothercodeanalysisimprovementss_and_other_improvements">博文</a>中详细了解 IntelliJ IDEA 2023.2 中的新检查和其他代码分析改进。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959640.png"> </p><h3 id="格式字符串的代码高亮显示和导航"><a href="#格式字符串的代码高亮显示和导航" class="headerlink" title="格式字符串的代码高亮显示和导航"></a>格式字符串的代码高亮显示和导航</h3><p>现在，将文本光标置于格式说明符上后，IDE 将高亮显示相应实参和指向它的其他说明符。 此外，您现在可以使用 _Go To Declaration_（转到声明）(Ctrl+B) 跳转到特定格式字符串占位符的关联代码位置。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959020.png"> </p><h3 id="改进了对-Javadoc-注释中-snippet-标记的支持"><a href="#改进了对-Javadoc-注释中-snippet-标记的支持" class="headerlink" title="改进了对 Javadoc 注释中 @snippet 标记的支持"></a>改进了对 Javadoc 注释中 <code>@snippet</code> 标记的支持</h3><p>IntelliJ IDEA 改进了 Javadoc 注释中的 <code>@snippet</code> 标记功能。 它允许在 <code>@snippet</code> 标记内添加标记注释，并在文档中正确呈现。 代码区域已得到支持，您可以指定要在 Javadoc 注释中引用的代码部分。 此外，IDE 现在还支持在 <code>@snippet</code> 标记内包含外部代码段，这将允许您引用存储在单独文件或源中的代码段，并将其包含在 Javadoc 文档中。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959078.png"> </p><h3 id="扩展了多个选定成员的重构选项"><a href="#扩展了多个选定成员的重构选项" class="headerlink" title="扩展了多个选定成员的重构选项"></a>扩展了多个选定成员的重构选项</h3><p>我们添加了新方式，可供同时将特定重构应用于多个成员。 现在，您可以在 _Project_（项目）或 _Structure_（结构）工具窗口中直接选择多个成员，同时对其调用 _Extract Delegate_（提取委托）、_Extract Interface_（提取接口）、_Extract Superclass_（提取超类）、_Pull Members Up_（向上拉取成员）和 _Push Members Down_（向下推送成员）。 此外，IntelliJ IDEA 现在支持以多文本光标选择进行扩展范围的重构，包括 _Encapsulate Fields_（封装字段）、_Move Static Members_（移动 static 成员）、_Extract Delegate_（提取委托）、_Extract Interface_（提取接口）和 _Extract Superclass_（提取超类）。 要利用此功能，请将文本光标放置在您希望应用重构的各成员中，IDE 将自动在重构对话框中预选并检查这些成员。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959060.png"> </p><h3 id="改进了堆栈跟踪分析的导航"><a href="#改进了堆栈跟踪分析的导航" class="headerlink" title="改进了堆栈跟踪分析的导航"></a>改进了堆栈跟踪分析的导航</h3><p>为了改进堆栈跟踪分析并更快地解决 bug，IntelliJ IDEA 现在可以准确猜测报告中方法的位置，即使行号不可用或已偏离。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959089.png"> </p><h3 id="增强了动态-SQL-查询的污点分析"><a href="#增强了动态-SQL-查询的污点分析" class="headerlink" title="增强了动态 SQL 查询的污点分析"></a>增强了动态 SQL 查询的污点分析</h3><p>Ultimate IntelliJ IDEA 现在可以更好地分析 Java 和 Kotlin 中 SQL 的串联和内插，检测潜在的不安全查询，使代码避免可能的 SQL 注入漏洞。 </p><h1 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959113.png"> </p><h3 id="更出色的-Scala-3-支持"><a href="#更出色的-Scala-3-支持" class="headerlink" title="更出色的 Scala 3 支持"></a>更出色的 Scala 3 支持</h3><p>IntelliJ IDEA 2023.2 增强了 Scala 3 支持，专注于简化开发体验。 值得注意的改进包括对 Scala 3 枚举高亮显示的修正、枚举定义导航，以及多种上下文中枚举 case 的正确解析。 TASTy 反编译器得到显著增强，确保对 Akka、Cats、Play、ZIO 等流行 Scala 库进行准确的反编译。 此外，调试器中的 <code>scala-expression-compiler</code> 集成也将为 Scala 开发者提供更好的调试体验。 其他改进包括 Scala 3 通用应用方法的增强补全提示、对 IArray 的编辑器内支持，以及对“更少大括号”语法的改进支持。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959170.png"> </p><h3 id="更好的-sbt-支持"><a href="#更好的-sbt-支持" class="headerlink" title="更好的 sbt 支持"></a>更好的 sbt 支持</h3><p>此版本对 IntelliJ IDEA 的 sbt 支持进行了许多改进。 重新打开项目后，为 sbt 设置的环境变量将被保留并正确处理。 重新设计的设置页面 _File | Settings | Build, Execution, Deployment | Build Tools | sbt_（文件 | 设置 | 构建、执行、部署 | 构建工具 | sbt）更为易用，并新增了 _Environment variables_（环境变量）字段，因此，您可以将自定义环境变量传递到 sbt-shell 进程。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959482.png"> </p><h3 id="ScalaDoc-呈现"><a href="#ScalaDoc-呈现" class="headerlink" title="ScalaDoc 呈现"></a>ScalaDoc 呈现</h3><p>在这个版本中，ScalaDoc 的快速文档与 Javadoc 的更加一致。 现在，显示的声明中的注解、关键字和文字将根据所选主题高亮显示。 如果超出可用空间，扩展的特征和类的列表将分成多行。 此外，文档中现在也支持 Scala 3 关键字。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959505.png"> </p><h3 id="修正了类型推断错误"><a href="#修正了类型推断错误" class="headerlink" title="修正了类型推断错误"></a>修正了类型推断错误</h3><p>新版本对某些复杂或罕见情况下的无效类型推断进行了许多修正，例如类型具有复杂边界、sealed 特征层次结构可能不清晰或在复杂模式匹配中的情况。</p><h3 id="Zinc-作为默认编译器"><a href="#Zinc-作为默认编译器" class="headerlink" title="Zinc 作为默认编译器"></a>Zinc 作为默认编译器</h3><p>鉴于 Zinc 最近的性能改进，我们在 v2023.2 中将其设为默认增量编译器。 这确保了对 Scala 3 新功能（包括 <code>inline</code> 方法）的增量编译的全面支持。</p><h3 id="改进了源目录和目标目录的管理"><a href="#改进了源目录和目标目录的管理" class="headerlink" title="改进了源目录和目标目录的管理"></a>改进了源目录和目标目录的管理</h3><p>目标文件夹的子文件夹不再自动包含为源，除非它们被标记为托管。 这将加快在生成源代码的项目中进行搜索的速度。 此外，IDE 还为 <code>sbt-projectmatrix</code> 提供了更好的支持。 </p><h1 id="性能分析器"><a href="#性能分析器" class="headerlink" title="性能分析器"></a>性能分析器</h1><p>—– <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959514.png"> </p><h3 id="从-Run-（运行）工具窗口使用分析功能"><a href="#从-Run-（运行）工具窗口使用分析功能" class="headerlink" title="从 _Run_（运行）工具窗口使用分析功能"></a>从 _Run_（运行）工具窗口使用分析功能</h3><p>Ultimate 在 IntelliJ IDEA 2023.2 中，您可以直接从 _Run_（运行）工具窗口轻松访问 IntelliJ 分析器的功能。 使用新按钮，点击一下即可调用 _Attach IntelliJ Profiler_（附加 IntelliJ 分析器）和 _Capture Memory Snapshot_（捕获内存快照）操作，无需打开 _Profiler_（分析器）工具窗口或从头启动应用程序。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959496.png"> </p><h3 id="默认挂钟分析模式"><a href="#默认挂钟分析模式" class="headerlink" title="默认挂钟分析模式"></a>默认挂钟分析模式</h3><p>Ultimate 我们将挂钟分析模式设为默认选项，增强了 IntelliJ IDEA 2023.2 中的分析体验。 此分析方法会考虑在方法中花费的总时间，包括等待时间。 它以毫秒为测量单位，是更强大、更直观的选项。</p><h1 id="运行-调试"><a href="#运行-调试" class="headerlink" title="运行&#x2F;调试"></a>运行&#x2F;调试</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959539.png"> </p><h3 id="Reactor-Mono-和-Flux-值求算"><a href="#Reactor-Mono-和-Flux-值求算" class="headerlink" title="Reactor Mono 和 Flux 值求算"></a>Reactor <code>Mono</code> 和 <code>Flux</code> 值求算</h3><p>Ultimate 调试反应式应用程序时，您现在可以轻松求算 <code>Mono</code> 和 <code>Flux</code> 类型的监视和局部变量的值。 IDE 现在会在调试会话期间进行检测，并在 _Variables_（变量）视图中提供相应的 <code>get</code> 或 <code>collectList</code> 链接，点击即可立即计算 Reactive Streams 条目。 默认情况下，调试器会获取 <code>Flux</code> 的前 100 个条目。 您可以在 _File | Settings | Languages &amp; Frameworks | Reactive Streams_（文件 | 设置 | 语言和框架 | Reactive Streams）中配置此数量。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959545.png"> </p><h3 id="Gradle、Maven-和-JPS-项目的持续测试"><a href="#Gradle、Maven-和-JPS-项目的持续测试" class="headerlink" title="Gradle、Maven 和 JPS 项目的持续测试"></a>Gradle、Maven 和 JPS 项目的持续测试</h3><p>我们扩展了自动测试功能，使其与 Maven、Gradle 和 JPS 构建系统完全兼容。 我们还使持续测试模式更易激活。 要启用该模式，请使用 _Run&#x2F;Debug_（运行&#x2F;调试）工具窗口中新增的 _Rerun Automatically_（自动重新运行）按钮。 每当更改保存时，测试都会自动运行，对代码更新提供即时反馈。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959903.png"> </p><h3 id="return-语句的内联断点"><a href="#return-语句的内联断点" class="headerlink" title="return 语句的内联断点"></a>return 语句的内联断点</h3><p>IntelliJ IDEA 提供了对直接在 return 语句处设置断点的改进支持，类似于已在 lambda 表达式中实现的设置方式。 这一改进将为开发者提供更高的调试精度和更深入的代码分析，带来更有价值的代码行为和返回值洞察。 要设置内联断点，只需右键点击语句旁边的装订区域并选择 <em>return</em> 选项即可。</p><h1 id="版本控制系统"><a href="#版本控制系统" class="headerlink" title="版本控制系统"></a>版本控制系统</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959958.png"> </p><h3 id="提交特定代码行的选项"><a href="#提交特定代码行的选项" class="headerlink" title="提交特定代码行的选项"></a>提交特定代码行的选项</h3><p>IntelliJ IDEA 2023.2 引入了一项备受期待的功能，可供有选择地提交代码区块的特定部分。 要执行部分提交，请选择区块中的行，然后从上下文菜单中调用 _Include these lines into commit_（将所选行包含到提交中）。 区块将被分为单独的行，所选行将被高亮显示。 您可以使用复选框或上下文菜单在选区中添加或排除行。 </p><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959046.png"> </p><h3 id="轻松生成共享索引的新工具"><a href="#轻松生成共享索引的新工具" class="headerlink" title="轻松生成共享索引的新工具"></a>轻松生成共享索引的新工具</h3><p>IntelliJ IDEA 2023.2 提供了新的命令行工具，用于快速构建和上传共享索引。 它旨在简化团队合作并消除本地索引大型项目花费的时间。 新工具将简化为团队生成共享索引的过程，只需几下点击，无需多个脚本和服务。 <a href="https://blog.jetbrains.com/idea/2023/05/intellij-idea-2023-2-eap/#Newtoolforeasilygeneratingsharedindexes">了解详情</a>。 </p><h1 id="框架和技术"><a href="#框架和技术" class="headerlink" title="框架和技术"></a>框架和技术</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959036.png"> </p><h3 id="在-WSL-上运行和调试"><a href="#在-WSL-上运行和调试" class="headerlink" title="在 WSL 上运行和调试"></a>在 WSL 上运行和调试</h3><p>Tomcat Ultimate 从 IntelliJ IDEA 2023.2 开始，您可以在适用于 Linux 的 Windows 子系统 (WSL) 上运行和调试部署到 Tomcat 的应用程序。 要在 WSL 上使用基于 Tomcat 的应用程序，您需要在 <code>/etc/environment</code> 或 <code>~/.bashrc</code> 文件中声明 <code>JAVA_HOME</code> 环境变量。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959971.png"> </p><h3 id="在-HTTP-客户端中使用-TLS-发送-gRPC-请求"><a href="#在-HTTP-客户端中使用-TLS-发送-gRPC-请求" class="headerlink" title="在 HTTP 客户端中使用 TLS 发送 gRPC 请求"></a>在 HTTP 客户端中使用 TLS 发送 gRPC 请求</h3><p>Ultimate 您现在可以在 HTTP 客户端中通过传输层安全 (TLS) 发送 gRPC 请求。 TLS 提供加密和身份验证，确保数据传输的保密性和完整性。 请求语法支持 <code>https://</code> 和 <code>grpcs://</code> 架构。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959025.png"> </p><h3 id="针对-Swagger-Codegen-的改进"><a href="#针对-Swagger-Codegen-的改进" class="headerlink" title="针对 Swagger Codegen 的改进"></a>针对 Swagger Codegen 的改进</h3><p>Ultimate 设置 Swagger Codegen 配置时，IDE 现在将提供更好的用户体验。 我们重做了 _Edit Swagger Codegen Configuration_（编辑 Swagger Codegen 配置）对话框，让您可以更轻松地根据需求定制运行配置。 另外，您现在还可以直接从装订区域访问 Swagger Codegen 运行配置，无需指定额外设置。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959353.png"></p><h3 id="HTTP-客户端中对-Swagger-和-OpenAPI-架构的支持"><a href="#HTTP-客户端中对-Swagger-和-OpenAPI-架构的支持" class="headerlink" title="HTTP 客户端中对 Swagger 和 OpenAPI 架构的支持"></a>HTTP 客户端中对 Swagger 和 OpenAPI 架构的支持</h3><p>Ultimate HTTP 客户端现在能够理解 Swagger 和 OpenAPI 规范，并为 JSON 请求正文提供相应的代码补全选项。 <a href="https://www.jetbrains.com.cn/idea/whatsnew/2023-2/img/Redoc_UI_previews_for_OpenAPI_and_Swagger_files.png"><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959537.png"> </a> </p><h3 id="OpenAPI-和-Swagger-文件的-Redoc-UI-预览"><a href="#OpenAPI-和-Swagger-文件的-Redoc-UI-预览" class="headerlink" title="OpenAPI 和 Swagger 文件的 Redoc UI 预览"></a>OpenAPI 和 Swagger 文件的 Redoc UI 预览</h3><p>Ultimate IntelliJ IDEA 现已支持 OpenAPI 和 Swagger 规范文件（包括 YAML 和 JSON 文件）的 <a href="https://redocly.com/">Redoc UI</a> 预览，允许您在 IDE 内的 Redoc 和 Swagger UI 之间切换。 通过 Redocly 集成，您可以从 IntelliJ IDEA 中访问 <em>Try it</em> 控制台，使用它设置参数并向 API 发送请求。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959485.png"></p><h3 id="JavaScript-中的-JSON-正文补全"><a href="#JavaScript-中的-JSON-正文补全" class="headerlink" title="JavaScript 中的 JSON 正文补全"></a>JavaScript 中的 JSON 正文补全</h3><p>Ultimate IDE 现在为 JavaScript 代码中的 JSON 对象键提供补全，例如使用 <code>fetch()</code> 调用或引用 Axios 库的代码。 Spring MVC 服务器端点现已得到支持，未来将有更多服务器框架加入支持列表。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959552.png"> ###  HTTP 客户端中对 JavaScript 导入的支持 Ultimate 在 IntelliJ IDEA 2023.2 中，现在可以通过导入的模块共享 HTTP 客户端请求处理程序的通用 JavaScript 代码。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959618.png"> </p><h3 id="HTTP-客户端中响应的-PDF-和-HTML-预览"><a href="#HTTP-客户端中响应的-PDF-和-HTML-预览" class="headerlink" title="HTTP 客户端中响应的 PDF 和 HTML 预览"></a>HTTP 客户端中响应的 PDF 和 HTML 预览</h3><p>Ultimate IntelliJ IDEA 现在能够在 HTTP 客户端的请求结果中显示 PDF 和 HTML 文件的预览。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959614.png"> </p><h3 id="HTTP-客户端-CLI-中对-GraphQL-和-WebSocket-的支持"><a href="#HTTP-客户端-CLI-中对-GraphQL-和-WebSocket-的支持" class="headerlink" title="HTTP 客户端 CLI 中对 GraphQL 和 WebSocket 的支持"></a>HTTP 客户端 CLI 中对 GraphQL 和 WebSocket 的支持</h3><p>Ultimate 您现在可以在 IntelliJ IDEA 中使用 <a href="https://blog.jetbrains.com/idea/2022/12/http-client-cli-run-requests-and-tests-on-ci/">HTTP 客户端 CLI</a> 与 GraphQL API 交互，并与服务建立 WebSocket 连接，用于测试或自动化脚本。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959658.png"> </p><h3 id="VM-options-（虚拟机选项）中-Spring-Boot-配置键的自动补全"><a href="#VM-options-（虚拟机选项）中-Spring-Boot-配置键的自动补全" class="headerlink" title="_VM options_（虚拟机选项）中 Spring Boot 配置键的自动补全"></a>_VM options_（虚拟机选项）中 Spring Boot 配置键的自动补全</h3><p>Ultimate 设置新的 Spring Boot 运行配置时，_VM options_（虚拟机选项）字段为 <code>-D</code> 标志后面出现的键提供自动补全选项。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959859.png"> </p><h3 id="Spring-配置-Bean-不再需要注解处理器"><a href="#Spring-配置-Bean-不再需要注解处理器" class="headerlink" title="Spring 配置 Bean 不再需要注解处理器"></a>Spring 配置 Bean 不再需要注解处理器</h3><p>Ultimate 我们简化了在 IntelliJ IDEA 中使用 Spring 的自定义配置 Bean 时的用户体验。 IDE 现在会在属性和 YAML 配置文件中提供代码补全和验证，无需设置 Spring Boot 配置注解处理器。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959914.png"></p><h3 id="Kotlin-中对-Spring-AOP-的支持"><a href="#Kotlin-中对-Spring-AOP-的支持" class="headerlink" title="Kotlin 中对 Spring AOP 的支持"></a>Kotlin 中对 Spring AOP 的支持</h3><p>Ultimate 我们扩展了 IntelliJ IDEA 对在 Spring 应用程序中使用 AspectJ 的支持。 IDE 现在可为 Kotlin 代码提供分析和补全，此前已经为 Java 代码提供。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959945.png"> </p><h3 id="针对检测-YAML-文件中不匹配值类型的新检查"><a href="#针对检测-YAML-文件中不匹配值类型的新检查" class="headerlink" title="针对检测 YAML 文件中不匹配值类型的新检查"></a>针对检测 YAML 文件中不匹配值类型的新检查</h3><p>Ultimate 在 IntelliJ IDEA 2023.2 中，我们引入了一项新检查，旨在消除 <a href="https://hitchdev.com/strictyaml/why/implicit-typing-removed/">Norway Problem</a> 并防止对 YAML 文件中布尔值的意外误解。 当列表主要由字符串组成但包含布尔式文字时，IntelliJ IDEA 将高亮显示此文字，指示潜在的不一致，并建议为其添加引号。 如果列表主要由布尔式文字（例如 <code>true</code>、<code>false</code>、<code>off</code>、<code>on</code>、<code>yes</code> 或 <code>no</code>）组成，则偏离此模式的任何文字都将被高亮显示为可能的错误，不过，在这种情况下不会建议具体的快速修复。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959056.png"> </p><h3 id="对编辑-AsyncAPI-文件的支持"><a href="#对编辑-AsyncAPI-文件的支持" class="headerlink" title="对编辑 AsyncAPI 文件的支持"></a>对编辑 AsyncAPI 文件的支持</h3><p>Ultimate 现在，在 IntelliJ IDEA 中使用 AsyncAPI 规范格式更加简单。 IDE 支持架构验证功能，并为引用、_Endpoints_（端点）视图和 _Editor Preview_（编辑器预览）窗格提供了代码补全。 </p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959064.png"> </p><h3 id="在-Docker-镜像层内预览文件"><a href="#在-Docker-镜像层内预览文件" class="headerlink" title="在 Docker 镜像层内预览文件"></a>在 Docker 镜像层内预览文件</h3><p>现在可以在 _Services_（服务）工具窗口中轻松访问和预览 Docker 镜像层的内容。 从列表选择镜像，选择 _Show layers_（显示层），然后点击 _Analyze image for more information_（分析镜像以获得更多信息）。 这将打开层中存储的文件列表，您可以右键点击文件，然后点击 _Open File_（打开文件）（对于二进制文件，则为 _Download File_（下载文件）），在编辑器中轻松打开所选文件。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959981.png"></p><h3 id="将-Docker-容器设为作为运行配置的-Before-Launch-（启动前）任务运行"><a href="#将-Docker-容器设为作为运行配置的-Before-Launch-（启动前）任务运行" class="headerlink" title="将 Docker 容器设为作为运行配置的 _Before Launch_（启动前）任务运行"></a>将 Docker 容器设为作为运行配置的 _Before Launch_（启动前）任务运行</h3><p>现在，可以将 Docker 运行配置指定为 _Before Launch_（启动前）任务，从而在另一个配置之前运行。 IDE 将等待当前运行的容器恢复正常，然后再启动下一个运行配置。 要将 Docker 运行配置放入队列中，首先创建配置，然后通过 _Modify options | Add before launch task | Run configuration_（修改选项 | 添加启动前任务 | 运行配置）将其添加到相关容器中。 </p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959225.png"></p><h3 id="对单个项目中多个-kubeconfig-文件的支持"><a href="#对单个项目中多个-kubeconfig-文件的支持" class="headerlink" title="对单个项目中多个 kubeconfig 文件的支持"></a>对单个项目中多个 kubeconfig 文件的支持</h3><p>Ultimate 这项新引入的功能允许您在单个项目中设置多个 kubeconfig 文件。 这简化了处理多个集群或在同一项目中的不同集群上使用环境的体验。 转到 _File | Settings | Build, Execution, Deployment | Kubernetes_（文件 | 设置 | 构建、执行、部署 | Kubernetes）即可设置文件。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959309.png"></p><h3 id="查看部署日志"><a href="#查看部署日志" class="headerlink" title="查看部署日志"></a>查看部署日志</h3><p>Ultimate 现在，您可以在 _Services_（服务）工具窗口中查看 Kubernetes 集群中的部署日志。 右键点击树中的 _Deployment_（部署），然后从上下文菜单中选择 _Follow Log_（关注日志）或 _Download Log_（下载日志）。 </p><h1 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959321.png"> </p><h3 id="针对-JavaScript-和-TypeScript-改进了错误格式设置"><a href="#针对-JavaScript-和-TypeScript-改进了错误格式设置" class="headerlink" title="针对 JavaScript 和 TypeScript 改进了错误格式设置"></a>针对 JavaScript 和 TypeScript 改进了错误格式设置</h3><p>Ultimate 我们在 IntelliJ IDEA 2023.2 中关注如何改进呈现 JavaScript 和 TypeScript 中类型错误的方式。 现在，您的错误和警告将以可读性更高的方式格式化，使代码中的问题更易发现。 这适用于所有 TypeScript 和一些最常见的 JavaScript 错误，甚至包括本地化后的错误。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959371.png"> </p><h3 id="CSS-嵌套支持"><a href="#CSS-嵌套支持" class="headerlink" title="CSS 嵌套支持"></a>CSS 嵌套支持</h3><p>Ultimate IntelliJ IDEA 2023.2 现在支持 <a href="https://www.w3.org/TR/css-nesting-1/">CSS 嵌套</a>。 我们实现了语法支持和检查，新检查会在嵌套选择器以标识符或函数符号开头时发出提醒。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959418.png"> </p><h3 id="Vue-语言服务器支持"><a href="#Vue-语言服务器支持" class="headerlink" title="Vue 语言服务器支持"></a>Vue 语言服务器支持</h3><p>Ultimate Vue 语言服务器（VLS，又称 Volar）支持可在快速导航和文档弹出窗口中提供更准确的错误检测和更好的类型信息。 VLS 默认将用于 TypeScript v5.0 及更高版本，TypeScript 服务的包装器将用于更低版本的 TypeScript。 在 _Settings | Languages &amp; Frameworks | TypeScript | Vue_（设置 | 语言和框架 | TypeScript | Vue）下，您可以将 Vue 服务设置为在所有 TypeScript 版本上使用 VLS 集成。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959448.png"> </p><h3 id="适用于-React-挂钩的新实时模板"><a href="#适用于-React-挂钩的新实时模板" class="headerlink" title="适用于 React 挂钩的新实时模板"></a>适用于 React 挂钩的新实时模板</h3><p>Ultimate 我们在 _Settings | Editor | Live Templates | React hooks_（设置 | 编辑器 | 实时模板 | React 挂钩）下为 React 挂钩添加了一组新的实时模板。 要使用实时模板，首先在编辑器中输入缩写，然后按 <em>Tab</em> 将其展开。 </p><h1 id="代码质量工作流"><a href="#代码质量工作流" class="headerlink" title="代码质量工作流"></a>代码质量工作流</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959591.png"> </p><h3 id="捆绑了-Qodana-代码质量平台"><a href="#捆绑了-Qodana-代码质量平台" class="headerlink" title="捆绑了 Qodana 代码质量平台"></a>捆绑了 Qodana 代码质量平台</h3><p>通过完全集成我们旨在适应任何 CI&#x2F;CD 管道的智能静态分析引擎 <a href="https://www.jetbrains.com.cn/qodana/?utm_campaign=idea_x_qodana&utm_medium=referral&utm_source=whatsnew">JetBrains Qodana</a>，IntelliJ IDEA 2023.2 简化了静态分析工具的配置。 这一集成具备两大重要优势。 首先，简单的配置让您只需点击几下即可触发分析、查看项目级问题，以及在首选 CI&#x2F;CD 系统中设置质量门。 其次，您现在无需离开 IDE 即可直接查看服务器端分析结果。 在这篇<a href="https://blog.jetbrains.com/qodana/2023/07/qodana-is-out-of-preview-with-first-class-jetbrains-ide-integration/">博文</a>中详细了解 Qodana 及其最新版本。 </p><h1 id="数据库工具"><a href="#数据库工具" class="headerlink" title="数据库工具"></a>数据库工具</h1><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959039.png"> </p><h3 id="Redis-Cluster-支持"><a href="#Redis-Cluster-支持" class="headerlink" title="Redis Cluster 支持"></a>Redis Cluster 支持</h3><p>Ultimate 您现在可以连接到 Redis Cluster 并拥有与独立 Redis 相同的功能集。 连接到集群时，必须在所需 URL 之前输入 <code>jdbc:redis:cluster:</code>。 为此，您需要选择适当的连接类型。 如果连接到集群需要 SSH 隧道，应在 URL 中指明集群中所有节点的主机和端口。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959076.png"> </p><h3 id="架构迁移对话框的新-UI"><a href="#架构迁移对话框的新-UI" class="headerlink" title="架构迁移对话框的新 UI"></a>架构迁移对话框的新 UI</h3><p>Ultimate 在 v2023.2 中，我们重做了架构迁移功能。 主要区别在于，同一个对象现在位于对话框两个部分的同一行上，从而更清晰地显示将在目标架构中添加、移除或更改的对象。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959109.png"> </p><h3 id="数据编辑器的-Time-zone-（时区）设置"><a href="#数据编辑器的-Time-zone-（时区）设置" class="headerlink" title="数据编辑器的 _Time zone_（时区）设置"></a>数据编辑器的 _Time zone_（时区）设置</h3><p>Ultimate _Data Editor and Viewer_（数据编辑器和查看器）设置页面新增了 _Time zone_（时区）字段，用于设置显示 <code>datetime</code> 值的时区。 <img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308051959129.png"> </p><h3 id="对-Redshift-中外部数据库和数据共享的支持"><a href="#对-Redshift-中外部数据库和数据共享的支持" class="headerlink" title="对 Redshift 中外部数据库和数据共享的支持"></a>对 Redshift 中外部数据库和数据共享的支持</h3><p>Ultimate 现在，共享数据库及其内容均会内省。 创建这些数据库的数据共享也会内省。 </p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>在这个版本中，我们为想要在 IDE 中使用特定 LSP 服务器提供编码辅助的插件开发者引入了 LSP API。 如果您已经创建了自己的编程语言或框架，则可以创建 LSP 服务器和插件以在 IDE 中获得支持。 请注意，此功能仅在 IDE 的付费版本中可用。 <a href="https://blog.jetbrains.com/platform/2023/07/lsp-for-plugin-developers/">了解详情</a>。 </li><li>我们分解了 <a href="https://plugins.jetbrains.com/plugin/12494-big-data-tools">Big Data Tools</a> 插件，允许单独使用其各个部分。 这让 IntelliJ IDEA 得到六个新插件：<a href="https://plugins.jetbrains.com/plugin/21704-kafka">Kafka</a>、<a href="https://plugins.jetbrains.com/plugin/21700-spark">Spark</a>、<a href="https://plugins.jetbrains.com/plugin/21702-flink">Flink</a>、<a href="https://plugins.jetbrains.com/plugin/21706-remote-file-systems">Remote File Systems</a>、<a href="https://plugins.jetbrains.com/plugin/21701-big-data-file-viewer">Big Data File Viewer</a> 和 <a href="https://plugins.jetbrains.com/plugin/21673-zeppelin">Zeppelin</a>。 如果您需要全部六个插件，仍然可以一键安装 Big Data Tools 插件。 </li><li><pre><code> IntelliJ IDEA 捆绑的 Android 插件现在提供 Android Studio Giraffe Beta 2 的所有功能，包括对 Android Gradle Plugin (AGP) 8.0.0 的支持。 请注意，此支持不包括需要登录 Firebase 帐号的功能。 </code></pre></li><li><pre><code>    从 2023.2 开始，最大堆大小 (-Xmx) 的默认值已更改为 2 GB。</code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IDEA </tag>
            
            <tag> 更新日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Pages自定义域名</title>
      <link href="/2023/08/01/Github%20Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/"/>
      <url>/2023/08/01/Github%20Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Github-Pages自定义域名"><a href="#Github-Pages自定义域名" class="headerlink" title="Github Pages自定义域名"></a>Github Pages自定义域名</h1><p>当你想在网上发布内容时，配置Github Pages是一个很好的选择。如果你想要在自己的域名上发布，你可以使用Github Pages来创建自己的网站。本文将介绍如何使用Github Pages自定义域名。</p><p>这里呢先列出前置条件：</p><ul><li>您的Github Pages能正常访问</li><li>拥有自己的域名并备案成功</li></ul><p>关于如何创建Github Pages可以参考我之前的博客<a href="https://mp.weixin.qq.com/s/onryCTQHSSoFcJWAjziqig" title="https://mp.weixin.qq.com/s/onryCTQHSSoFcJWAjziqig">https://mp.weixin.qq.com/s/onryCTQHSSoFcJWAjziqig</a></p><p>下面详细介绍如何配置</p><h2 id="一、配置CName"><a href="#一、配置CName" class="headerlink" title="一、配置CName"></a>一、配置CName</h2><p>这里需要注意的是，记录值就是你的Github Pages地址，记录类型填写CName，主机记录就是你的二级域名地址</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308012309959.png"></p><h2 id="二、添加CNAME文件"><a href="#二、添加CNAME文件" class="headerlink" title="二、添加CNAME文件"></a>二、添加CNAME文件</h2><p>首先找到你的主分支，这个分支要和Setting里面配置的分支一致。然后创建一个NAME文件</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308012309973.png"></p><p>文件内容是<code>二级域名.自己的域名</code></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308012309943.png"></p><h2 id="三、访问配置的CNAME"><a href="#三、访问配置的CNAME" class="headerlink" title="三、访问配置的CNAME"></a>三、访问配置的CNAME</h2><p>这里等待几分钟，我这里几秒钟就刷出来了</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202308012309952.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> GithubPages </tag>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+GithubPages免费搭建个人博客网站</title>
      <link href="/2023/07/29/Hexo-GithubPages%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
      <url>/2023/07/29/Hexo-GithubPages%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-GithubPages免费搭建个人博客网站"><a href="#Hexo-GithubPages免费搭建个人博客网站" class="headerlink" title="Hexo+GithubPages免费搭建个人博客网站"></a>Hexo+GithubPages免费搭建个人博客网站</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#%E4%B8%80%E5%89%8D%E8%A8%80">一、前言</a></li><li><a href="#%E4%BA%8CGithub%E9%85%8D%E7%BD%AE">二、Github配置</a><ul><li><a href="#%E6%96%B0%E5%BB%BA%E5%90%8C%E5%90%8D%E4%BB%93%E5%BA%93">新建同名仓库</a></li><li><a href="#%E9%85%8D%E7%BD%AEPages">配置Pages</a></li></ul></li><li><a href="#%E4%B8%89%E5%AE%89%E8%A3%85Hexo">三、安装Hexo</a></li><li><a href="#%E5%9B%9B%E9%85%8D%E7%BD%AEhexo-deployer-git">四、配置hexo-deployer-git</a></li><li><a href="#%E4%BA%94%E8%AE%BF%E9%97%AE">五、访问</a></li><li><a href="#%E5%85%AD%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0">六、发布文章</a></li><li><a href="#%E4%B8%83%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98">七、安装主题</a></li></ul><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>我之前开了好几年的云服务器了，实际上使用场景并不是很多，感觉有点浪费。前两个月都给关掉了，现在呢琢磨着弄一个免费的云服务搭建个人博客。暂时先弄Github的，Gitee的那个要身份证，暂时弄不了，等等吧。</p><p>需要准备的环境：</p><p>windows的话需要准备node环境，可以关注某绿色软件回复：1009 不限速下载软件安装</p><p>这里列一下清单</p><ol><li>node环境</li><li>能访问github并准备好github账号</li></ol><h2 id="二、Github配置"><a href="#二、Github配置" class="headerlink" title="二、Github配置"></a>二、Github配置</h2><h3 id="新建同名仓库"><a href="#新建同名仓库" class="headerlink" title="新建同名仓库"></a>新建同名仓库</h3><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021025.png"></p><p>这里需要注意的有两点</p><ol><li>仓库名格式： username.github.io</li><li>仓库需要设置public，不能设置为private</li></ol><h3 id="配置Pages"><a href="#配置Pages" class="headerlink" title="配置Pages"></a>配置Pages</h3><p>在仓库主页点击Setting</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021979.png"></p><p>这里的配置按照以下方式配置即可</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021001.png"></p><p>OK，那么这里需要配置的完成了。</p><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>这里需要注意的是，需要先确认安装好了node环境，并配置了环境变量，可以通过cmd输入 <code>npm -v</code> 命令确认</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021887.png"></p><p>halo官网地址：<a href="https://hexo.io/zh-cn/" title="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p><p>安装很简单，直接在cmd中输入 <code>npm install hexo-cli -g</code> 即可</p><p>此时，需要在本地建立一个仓库，这个仓库中的文件将来会同步到github上。</p><p>建立方式是在cmd中输入 <code>hexo init</code> ，需要说明的是，需要在指定目录执行该命令，我这里推荐一个简单的方式。</p><ol><li>进入需要初始化仓库的文件夹下</li><li>左上角输入cmd</li><li>回车</li></ol><p>这样打开的cmd窗口自动进入到当前目录了</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021066.png"></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021947.png"></p><p>这样就算是创建好了，可以看到生成了一堆文件</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021916.png"></p><h2 id="四、配置hexo-deployer-git"><a href="#四、配置hexo-deployer-git" class="headerlink" title="四、配置hexo-deployer-git"></a>四、配置hexo-deployer-git</h2><p>官方地址：<a href="https://github.com/hexojs/hexo-deployer-git" title="https://github.com/hexojs/hexo-deployer-git">https://github.com/hexojs/hexo-deployer-git</a></p><p>安装也很简单，直接在cmd中输入  <code>npm install hexo-deployer-git --save</code></p><p>需要注意的是，执行该命令，需要在上面hexo初始化的仓库目录下执行，否则是没有用的。</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021574.png"></p><p>执行完效果如上图</p><p>我们需要关注的是生成的_config.yml文件，这里我们打开这个文件，并对部分配置做修改。</p><ol><li><p>修改url</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021546.png"></p></li><li><p>修改deploy</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021633.png"></p></li><li><p>这个配置可改可不改</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021598.png"></p></li></ol><p>修改完毕保存后，我们在cmd中执行命令 <code>helo d</code> 即可部署我们的项目，稍等几分钟，就能访问到了。</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021587.png"></p><p>正常到这边就结束了，但是后续多上传几次后就会报错</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021533.png"></p><p>这个原因可能是被限制了，我们需要配置token</p><p>打开github的settings</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021254.png"></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021142.png"></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021941.png"></p><p>权限勾选第一个就行了</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021896.png"></p><p>接下来我们需要在_config.yml中加上token</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021756.png"></p><h2 id="五、访问"><a href="#五、访问" class="headerlink" title="五、访问"></a>五、访问</h2><p>我的路由是：<a href="https://zysicyj.github.io/" title="https://zysicyj.github.io/">https://zysicyj.github.io/</a></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021678.png"></p><h2 id="六、发布文章"><a href="#六、发布文章" class="headerlink" title="六、发布文章"></a>六、发布文章</h2><p>官方文档：<a href="https://hexo.io/zh-cn/docs/commands" title="https://hexo.io/zh-cn/docs/commands">https://hexo.io/zh-cn/docs/commands</a></p><p>执行<code>hexo -new</code> 可以创建文件</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021581.png"></p><p>执行上传命令 <code>helo g &amp;&amp; hexo d</code> ，然后等几分钟，能看到文件已经同步上去了</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021450.png"></p><h2 id="七、安装主题"><a href="#七、安装主题" class="headerlink" title="七、安装主题"></a>七、安装主题</h2><p>我是用的主题是bufferfly <a href="https://butterfly.js.org/posts/21cfbf15/#%E5%AE%89%E8%A3%9D" title="https://butterfly.js.org/posts/21cfbf15/#安裝">https://butterfly.js.org/posts/21cfbf15/#安裝</a></p><p>仓库根目录下拉取代码</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021441.png"></p><p>修改_config.yml</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021501.png"></p><p>安装插件</p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021568.png"></p><p>重新生成部署 <code>hexo -g &amp;&amp; hexo d</code></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021719.png"></p><p><img src="https://njpkhuan-blog.oss-cn-shanghai.aliyuncs.com/202307290021226.png"></p><p>后续的话还有不少可以优化的地方，比如hexo主题，分类和标签问题，图片显示问题等等，这个后续再写文章吧</p>]]></content>
      
      
      
        <tags>
            
            <tag> GithubPages </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC学习笔记（上篇）</title>
      <link href="/2023/07/28/docs-IOC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/07/28/docs-IOC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="IOC学习笔记（上篇）"><a href="#IOC学习笔记（上篇）" class="headerlink" title="IOC学习笔记（上篇）"></a>IOC学习笔记（上篇）</h1><p>学习视频地址：<a href="https://time.geekbang.org/course/intro/100042601?tab=catalog">https://time.geekbang.org/course/detail/100042601-184049</a></p><h2 id="IOC容器的职责"><a href="#IOC容器的职责" class="headerlink" title="IOC容器的职责"></a>IOC容器的职责</h2><ul><li>依赖处理 <ul><li>依赖查找</li><li>依赖注入</li></ul></li><li>生命周期管理 <ul><li>容器</li><li>托管的资源（Java Beans 或其他资源<a href="#fn1">[1]</a>）</li></ul></li><li>配置 <ul><li>容器</li><li>外部化配置</li><li>托管的资源（Java Beans或其他资源<a href="#fn1">[1:1]</a>）</li></ul></li></ul><h2 id="Ioc容器的实现"><a href="#Ioc容器的实现" class="headerlink" title="Ioc容器的实现"></a>Ioc容器的实现</h2><ul><li>Java SE <ul><li>Java Beans</li><li>Java ServiceLoader SPI<a href="#fn2">[2]</a></li><li>JNDI（Java Naming and Directory Interface）</li></ul></li><li>Java EE <ul><li>EJB（Enterprise Java Beans）</li><li>Servlet</li></ul></li><li>开源 <ul><li>Apache Avalon（<a href="http://avalon.apache.org/closed.html%EF%BC%89">http://avalon.apache.org/closed.html）</a></li><li>PicoContainer（<a href="http://picocontainer.xn--com-c16s">http://picocontainer.com）</a></li><li>Google Guice（<a href="https://github.com/google/guice%EF%BC%89">https://github.com/google/guice）</a></li><li>Spring Framework（<a href="https://spring.io/projects/spring-framework%EF%BC%89">https://spring.io/projects/spring-framework）</a></li></ul></li></ul><h2 id="传统IoC容器的实现"><a href="#传统IoC容器的实现" class="headerlink" title="传统IoC容器的实现"></a>传统IoC容器的实现</h2><ul><li>Java Beans作为IoC容器</li><li>特性 <ul><li><a href="https://www.wolai.com/mRb4QGrHGR47QcZ7kJ1awQ">依赖查找</a></li><li>生命周期管理</li><li>配置元信息</li><li>事件</li><li>自定义</li><li>资源管理</li><li>持久化</li></ul></li><li>规范 <ul><li>JavaBeans：<a href="https://_www.oracle.com_technetwork_java_javase_tech_index-jsp-138795/">https://www.oracle.com/technetwork/java/javase/tech/index-jsp-138795.html</a></li><li>BeanContext：<a href="https://_docs.oracle.com_javase_8_docs_technotes_guides_beans_spec_beancontext/">https://docs.oracle.com/javase/8/docs/technotes/guides/beans/spec/beancontext.html</a></li></ul></li></ul><h2 id="依赖查找VS依赖注入"><a href="#依赖查找VS依赖注入" class="headerlink" title="依赖查找VS依赖注入"></a>依赖查找VS依赖注入</h2><ul><li>优劣对比</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2023/png/548519/1690289784867-c1b13ab7-3e36-48fe-84b0-5f23dccc0c3b.png#from=url&id=cgbg5&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p><h2 id="构造器注入VS-Setter注入"><a href="#构造器注入VS-Setter注入" class="headerlink" title="构造器注入VS Setter注入"></a>构造器注入VS Setter注入</h2><p>在选择构造器注入（Constructor Injection）和Setter注入（Setter Injection）之间，需要根据具体的情况来决定。<br>构造器注入是通过类的构造器来注入依赖对象，通常在创建对象的过程中完成注入。这种方式可以保证对象在创建完成后，其依赖关系已经完全被注入，使得对象在使用时具备完整的状态。构造器注入也可以使对象的依赖关系更加明确，减少了对于Setter方法的依赖。<br>Setter注入是通过类的Setter方法来注入依赖对象，通常在对象创建后通过调用Setter方法来完成注入。这种方式可以在对象创建后动态地修改其依赖关系，灵活性更高。Setter注入也可以支持可选的依赖，即某些依赖对象可以不注入而使用默认值。<br>选择构造器注入还是Setter注入，可以考虑以下几个方面：</p><ol><li>对象的依赖关系是否必须要在创建时注入，还是可以在对象创建后进行注入。如果依赖关系必须在创建时注入，那么构造器注入是更合适的选择；如果依赖关系可以在创建后动态修改，那么可以考虑使用Setter注入。</li><li>对象的依赖关系是否是必需的，还是可选的。如果某些依赖是必需的，而且没有合适的默认值，那么构造器注入可以确保这些依赖在创建时被注入；如果某些依赖是可选的，可以使用Setter注入，并提供默认值。</li><li>对象的可测试性。构造器注入可以使得对象的依赖关系更加明确，方便进行单元测试，因为可以通过构造器传入模拟对象。而Setter注入在单元测试中可能需要通过反射等方式来设置依赖对象。</li></ol><p>综上所述，选择构造器注入还是Setter注入取决于具体的情况。如果依赖关系必须在创建时注入，而且是必需的，那么构造器注入是更合适的选择；如果依赖关系可以在创建后动态修改，或者某些依赖是可选的，那么可以考虑使用Setter注入。同时，还需要考虑对象的可测试性和代码的可读性等因素。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="1-什么是IOC？"><a href="#1-什么是IOC？" class="headerlink" title="1. 什么是IOC？"></a>1. 什么是IOC？</h3><p>IOC，全称为Inversion of Control（控制反转），是一种软件设计原则和编程思想。它是面向对象编程（OOP）中的一种设计模式，用于解耦对象间的依赖关系。<br>在传统的程序设计中，对象之间的依赖关系由对象自身负责管理。例如，一个类在创建其他类的对象时，需要直接调用其他类的构造函数或方法来获取所需的对象。这种方式使得类之间紧密耦合，难以进行单元测试、代码复用和替换等操作。<br>而IOC是一种反转了对象创建和依赖关系管理的控制方式。在IOC中，对象的创建和依赖关系的管理由一个容器（Container）来负责。容器负责创建对象，并将依赖的对象注入到需要的地方。对象只需要定义自己所需的依赖，而不需要关心如何创建和管理这些依赖。这样可以实现对象间的解耦，提高代码的可维护性和可扩展性。<br>IOC的核心思想是通过依赖注入（Dependency Injection）来实现对象之间的解耦。依赖注入是指将需要的依赖对象通过构造器、Setter方法或其他方式注入到对象中，而不是由对象自己创建或获取依赖对象。依赖注入可以通过配置文件、注解或自动扫描等方式来实现。<br>IOC的好处包括：</p><ol><li>解耦：IOC通过将对象的创建和依赖关系的管理交给容器来处理，使得对象之间的关系更加松散，减少了耦合。</li><li>可测试性：由于对象的依赖关系由容器注入，可以方便地进行单元测试，通过替换依赖对象来进行测试或模拟。</li><li>可扩展性：在IOC中，可以通过配置文件或注解等方式来管理对象的依赖关系，使得系统更加灵活，能够方便地进行功能扩展或替换。</li></ol><p>常见的IOC框架包括Spring Framework、Google Guice等。这些框架提供了依赖注入的功能，可以帮助开发者实现IOC，并提供了其他的功能和工具来支持应用程序的开发。<br>总结来说，IOC（控制反转）是一种软件设计原则和编程思想，通过将对象的依赖关系的管理交给容器来处理，实现对象间的解耦。IOC的核心是依赖注入，将对象的依赖通过构造器、Setter方法或其他方式注入到对象中。IOC可以提高代码的可维护性、可测试性和可扩展性。</p><h3 id="2-依赖查找和依赖注入的区别"><a href="#2-依赖查找和依赖注入的区别" class="headerlink" title="2. 依赖查找和依赖注入的区别"></a>2. 依赖查找和依赖注入的区别</h3><p>依赖查找（Dependency Lookup）和依赖注入（Dependency Injection）是两种不同的依赖关系管理方式。<br>依赖查找是指通过容器或上下文来查找所需的依赖对象。在依赖查找中，对象自己负责获取它所依赖的对象，通常是通过容器提供的方法或API来获取。例如，通过容器的getBean()方法来获取所需的对象。<br>依赖注入是指将依赖对象通过构造器、Setter方法或其他方式注入到对象中。在依赖注入中，对象不需要关心如何获取依赖对象，而是通过注入的方式来获取。注入可以通过配置文件、注解或自动扫描等方式实现。<br>区别如下：</p><ol><li>控制方式不同：依赖查找是由对象自己控制获取依赖对象，而依赖注入是由容器控制将依赖对象注入到对象中。</li><li>依赖关系的表达方式不同：依赖查找需要在对象中显式调用容器提供的方法来获取依赖对象，而依赖注入是通过构造器、Setter方法或其他方式将依赖对象注入到对象中。</li><li>对象的可测试性不同：依赖查找在单元测试中可能需要使用模拟对象等技术来替代真实的依赖对象，而依赖注入可以通过注入不同的依赖对象来进行单元测试。</li><li>对象的依赖关系管理方式不同：依赖查找需要在每个对象中显式获取依赖对象，而依赖注入将依赖对象的管理交给容器来处理，对象只需要定义自己所需的依赖，不需要关心如何获取和管理这些依赖。</li></ol><p>综上所述，依赖查找和依赖注入是两种不同的依赖关系管理方式。依赖查找由对象自己负责获取依赖对象，而依赖注入是由容器负责将依赖对象注入到对象中。选择依赖查找还是依赖注入取决于具体的需求和设计风格。依赖注入通常被认为是更推荐的一种方式，因为它能够实现对象间的解耦，提高代码的可维护性和可测试性。</p><h3 id="3-Spring作为IOC容器有什么优势"><a href="#3-Spring作为IOC容器有什么优势" class="headerlink" title="3. Spring作为IOC容器有什么优势"></a>3. Spring作为IOC容器有什么优势</h3><p>Spring作为一个流行的IOC（控制反转）容器，具有以下优势：</p><ol><li>松耦合：Spring实现了依赖注入（DI）机制，通过将对象的依赖关系交由容器管理，实现了对象间的松耦合。这使得代码更容易理解、维护和扩展，提高了系统的灵活性。</li><li>可测试性：Spring的依赖注入机制使得对象的依赖关系通过构造器、Setter方法或其他方式注入，而不是直接在对象内部创建或获取依赖对象。这样，在进行单元测试时，可以更方便地替换依赖对象，进行集成测试和模块测试。</li><li>面向接口编程：Spring鼓励面向接口编程，通过接口来定义具体类的依赖关系。这种编程方式使得代码更具扩展性和可替换性，有利于实现多态和依赖倒置原则。</li><li>AOP支持：Spring提供了AOP（面向切面编程）的支持，通过配置和代理技术，可以实现横切关注点（例如事务管理、日志记录等）的集中管理和复用。这样，可以将业务逻辑与横切关注点分离，提高代码的重用性和可维护性。</li><li>生命周期管理：Spring容器管理对象的生命周期，可以在对象创建、初始化和销毁时执行相应的操作。例如，通过配置初始化方法和销毁方法，可以在对象创建和销毁时执行特定的逻辑。</li><li>配置灵活性：Spring采用基于XML、注解或Java配置的方式来进行配置，使得配置更加灵活和可扩展。可以根据具体需求选择合适的配置方式，方便地切换和修改配置，而不需要修改代码。</li><li>集成丰富：Spring提供了丰富的集成支持，可以与各种开源和商业框架进行集成，如Hibernate、MyBatis、Spring MVC等。这些集成支持简化了开发过程，提高了开发效率和系统的整合能力。</li></ol><p>总的来说，Spring作为一个IOC容器，通过依赖注入、面向接口编程、AOP支持、生命周期管理和灵活的配置等特性，提供了优秀的开发框架和工具，使得开发者能够更加专注于业务逻辑的实现，提高了系统的可维护性、可测试性和可扩展性。</p><hr><ol><li>比如监听器可以通过外部引入 <a href="#fnref1">↩︎</a><a href="">↩︎</a></li><li>从JDK1.6版本开始引入 <a href="#fnref2">↩︎</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> IOC </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
