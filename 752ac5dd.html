<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>JDK21 更新特性详解 | </title><meta name="keywords" content="Java,String Templates,Sequenced Collections,Generational ZGC,Record Patterns,Pattern Matching for switch,Foreign Function &amp; Memory API,废弃,Windows,32位,x86,支持,动态加载代理,安全性,类加载器,Instrumentation API,安全管理器,动态加载代理禁用准备,Java增强提案,密钥封装机制,密钥封装,密钥管理,密钥交换,密钥封装机制API,密钥封装机制API的优点,密钥封装机制API的缺点,结构化并发,并发编程,结构化并发的实现原理,结构化并发的优点,结构化并发的缺点,结构化并发的使用示例,结构化并发的使用注意事项"><meta name="author" content="程序员朱永胜"><meta name="copyright" content="程序员朱永胜"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="JDK21 更新特性详解"><meta name="application-name" content="JDK21 更新特性详解"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="JDK21 更新特性详解"><meta property="og:url" content="https://blog.zysicyj.top/752ac5dd.html"><meta property="og:site_name" content=""><meta property="og:description" content="有的时候博客内容会有变动，首发博客是最新的，其他博客地址可能会未同步, 认准https:&amp;#x2F;&amp;#x2F;blog.zysicyj.top    新特性  | 430: | String Templates (Preview) |1. 什么是 String Templates?String Templates"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://img.xjh.me/random_img.php?return=302&amp;_r_=02471b0c-1507-f753-774d-a8ca54cdd8ed"><meta property="article:author" content="程序员朱永胜"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://img.xjh.me/random_img.php?return=302&amp;_r_=02471b0c-1507-f753-774d-a8ca54cdd8ed"><meta name="description" content="有的时候博客内容会有变动，首发博客是最新的，其他博客地址可能会未同步, 认准https:&amp;#x2F;&amp;#x2F;blog.zysicyj.top    新特性  | 430: | String Templates (Preview) |1. 什么是 String Templates?String Templates"><link rel="shortcut icon" href="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/aliyun/202308012321669.jpg"><link rel="canonical" href="https://blog.zysicyj.top/752ac5dd.html"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-9343722716173603',
  enable_page_level_ads: 'true'
});</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16bc6435aa26c2ae803ad0e62e4f5fa8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":"3Is8EMFcqgGHzmLJ","LingQueMonitorID":"3Is8EMFcqgGHzmLJ"},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":1},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 程序员朱永胜","link":"链接: ","source":"来源: ","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '',
  title: 'JDK21 更新特性详解',
  postAI: '',
  pageFillDescription: '| 430 |  |, 1. 什么是 String Templates?, 2. 为什么需要 String Templates?, 3. String Templates 的实现原理?, 4. String Templates 的优点, 5. String Templates 的缺点, 6. String Templates 的使用示例 , 7. String Templates 的使用注意事项, 8. 总结, | 431 |  |, Sequenced Collections, 1. 什么是 Sequenced Collections？, 2. 为什么需要 Sequenced Collections？, 3. Sequenced Collections 的实现原理, 4. Sequenced Collections 的优点, 5. Sequenced Collections 的缺点, 6. Sequenced Collections 的使用示例 , 7. Sequenced Collections 的其他注意事项, 8. 总结, | 439 |  |, 1. 什么是 Generational ZGC?, 2. 为什么需要 Generational ZGC?, 3. Generational ZGC 的实现原理, 年轻代（Young Generation）, 老年代（Old Generation）, 并发处理, 4. Generational ZGC 的优点, 5. Generational ZGC 的缺点, 6. Generational ZGC 的使用示例 , 7. Generational ZGC 的使用注意事项, 8. 总结, | 440 |  |, 1. 什么是 Record Patterns?, 2. 为什么需要 Record Patterns?, 3. Record Patterns 的实现原理, 记录类型 , 模式匹配 , 4. Record Patterns 的优点, 5. Record Patterns 的缺点 , 6. Record Patterns 的使用示例 , 7. Record Patterns 的使用注意事项 , 8. 总结, | 441 |  |, 1. 什么是 Pattern Matching for switch?, 2. 为什么需要 Pattern Matching for switch?, 3. Pattern Matching for switch 的实现原理, 模式匹配 , 类型推断 , 4. Pattern Matching for switch 的优点, 5. Pattern Matching for switch 的缺点, 6. Pattern Matching for switch 的使用示例 , 7. Pattern Matching for switch 的使用注意事项, 8. 总结 , | 442 |  |, 1. 什么是 Foreign Function amp Memory API (Third Preview)?, 2. 为什么需要 Foreign Function amp Memory API?, 3. Foreign Function amp Memory API 的实现原理, 4. Foreign Function amp Memory API 的优点, 5. Foreign Function amp Memory API 的缺点, 6. Foreign Function amp Memory API 的使用示例 , 7. Foreign Function amp Memory API 的使用注意事项, 8. 总结 , | 443 |  |, 1. 什么是 Unnamed Patterns and Variables (Preview)?, 2. 为什么需要 Unnamed Patterns and Variables?, 3. Unnamed Patterns and Variables 的实现原理, 匿名模式 , 匿名变量 , 4. Unnamed Patterns and Variables 的优点, 5. Unnamed Patterns and Variables 的缺点 , 6. Unnamed Patterns and Variables 的使用示例 , 7. Unnamed Patterns and Variables 的使用注意事项 , 8. 总结 , | 444 |  |, 1. 什么是 Virtual Threads?, 2. 为什么需要 Virtual Threads?, 3. Virtual Threads 的实现原理, 4. Virtual Threads 的优点, 5. Virtual Threads 的缺点 , 6. Virtual Threads 的使用示例 , 7. Virtual Threads 的使用注意事项 , 8. 总结, | 445 |  |, 1. 什么是 Unnamed Classes and Instance Main Methods (Preview)?, 2. 为什么需要 Unnamed Classes and Instance Main Methods?, 3. Unnamed Classes and Instance Main Methods 的实现原理, 3.1 匿名类 , 3.2 实例主方法 , 4. Unnamed Classes and Instance Main Methods 的优点, 5. Unnamed Classes and Instance Main Methods 的缺点, 6. Unnamed Classes and Instance Main Methods 的使用示例 , 7. Unnamed Classes and Instance Main Methods 的使用注意事项, 8. 总结 , | 446 |  |, 1. 什么是 Scoped Values (Preview)?, 2. 为什么需要 Scoped Values (Preview)?, 3. Scoped Values (Preview) 的实现原理?, 4. Scoped Values (Preview) 的优点, 5. Scoped Values (Preview) 的缺点 , 6. Scoped Values (Preview) 的使用示例 , 7. Scoped Values (Preview) 的使用注意事项 , 8. 总结 , | 448 |  |, 1. 什么是 Vector API (Sixth Incubator)?, 2. 为什么需要 Vector API (Sixth Incubator)?, 3. Vector API (Sixth Incubator) 的实现原理?, 4. Vector API (Sixth Incubator) 的优点, 5. Vector API (Sixth Incubator) 的缺点, 6. Vector API (Sixth Incubator) 的使用示例 , 7. Vector API (Sixth Incubator) 的使用注意事项, 8. 总结 , | 449 |  |, 1. 什么是 JEP 449?, 2. 为什么需要废弃 Windows 32 位 x86 平台上的 Java 支持？, 3. JEP 449 的实现原理, 4. JEP 449 的优点, 5. JEP 449 的缺点, 6. JEP 449 的使用示例, 7. JEP 449 的使用注意事项, 8. 总结, | 451 |  |, 1. 什么是动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of Agents）？, 2. 为什么需要动态加载代理禁用准备？, 3. 动态加载代理禁用准备的实现原理 , 3.1 修改 ClassLoader, 3.2 修改 Instrumentation API, 3.3 更新安全管理器 , 4. 动态加载代理禁用准备的优点, 5. 动态加载代理禁用准备的缺点, 6. 动态加载代理禁用准备的使用示例 , 7. 动态加载代理禁用准备的使用注意事项, 8. 总结 , | 452 |  |, 1. 什么是 Key Encapsulation Mechanism API?, 2. 为什么需要 Key Encapsulation Mechanism API?, 3. Key Encapsulation Mechanism API 的实现原理, 4. Key Encapsulation Mechanism API 的优点, 5. Key Encapsulation Mechanism API 的缺点, 6. Key Encapsulation Mechanism API 的使用示例 , 7. Key Encapsulation Mechanism API 的使用注意事项, 8. 总结 , | 453 |  |, 什么是结构化并发（Structured Concurrency）？, 为什么需要结构化并发？, 结构化并发的实现原理 , 结构化并发的优点, 结构化并发的缺点, 结构化并发的使用示例 , 结构化并发的使用注意事项, 总结 有的时候博客内容会有变动首发博客是最新的其他博客地址可能会未同步认准新特性什么是是中引入的一个新特性它允许我们在字符串中使用占位符来动态替换变量的值它提供了一种更简洁更直观的方式来构建字符串而不需要使用传统的字符串拼接或格式化方法为什么需要在传统的中我们通常使用字符串拼接或格式化方法来构建动态字符串这种方式需要手动处理变量的值并且容易出错而且当字符串中包含大量变量时代码会变得冗长且难以维护的引入解决了这个问题它提供了一种更简洁更易读的方式来构建动态字符串通过使用占位符我们可以将变量的值直接嵌入到字符串中而不需要手动处理的实现原理的实现原理是通过在字符串中使用占位符来表示变量在运行时编译器会将这些占位符替换为实际的变量值具体来说当我们使用时编译器会将字符串中的占位符解析为一个特殊的表达式并将其转换为对应的变量值这个过程是在编译时完成的所以在运行时不会有额外的性能开销的优点简洁易读使用占位符来表示变量使得代码更加简洁易读类型安全在编译时会进行类型检查确保变量的类型与占位符的类型匹配避免了运行时的类型错误性能优化的解析过程是在编译时完成的所以在运行时不会有额外的性能开销可扩展性支持自定义的格式化函数可以根据需求进行扩展的缺点兼容性是中引入的新特性需要使用或更高版本的才能使用语法限制的占位符只能用于表示变量不能用于执行任意的表达式可读性当字符串中包含大量的占位符时可能会降低代码的可读性的使用示例下面是一个使用的简单示例输出结果为的使用注意事项占位符中的变量名必须是有效的标识符占位符中的变量值可以是任意类型编译器会自动进行类型转换如果变量值为占位符会被替换为字符串支持嵌套使用可以在占位符中使用其他占位符特别容易卡住然后就喊我总结是中引入的一个新特性它提供了一种更简洁更直观的方式来构建动态字符串通过使用占位符我们可以将变量的值直接嵌入到字符串中而不需要手动处理具有简洁易读类型安全性能优化和可扩展性等优点但也存在兼容性语法限制和可读性等缺点在使用时需要注意占位符的命名规则和变量值的类型什么是是中的一个新特性它是通过引入的是一种新的集合类型它提供了一种有序的线程安全的集合实现它的目标是提供一种高效的可扩展的有序集合以满足在多线程环境下处理大量数据的需求为什么需要在并发编程中处理大量数据时有序集合是非常常见的需求然而标准库中的集合类如等并不是线程安全的因此在多线程环境下使用它们可能会导致数据不一致的问题为了解决这个问题开发人员通常需要使用同步机制如关键字或对象来保证集合的线程安全性但这会带来额外的开销和复杂性的目标就是提供一种高效的可扩展的有序集合以解决在多线程环境下处理大量数据时的线程安全问题的实现原理的实现基于一种称为的机制是一种特殊的锁机制它允许多个线程同时读取集合中的数据但只允许一个线程进行写操作这种机制可以提高并发性能同时保证数据的一致性在中每个元素都有一个唯一的序列号用于标识元素的顺序读操作可以并发进行而写操作则需要获取锁来保证原子性当一个线程进行写操作时其他线程可以继续读取集合中的数据但不能进行写操作直到写操作完成的优点线程安全提供了线程安全的集合实现可以在多线程环境下安全地访问和修改集合中的数据高效性能使用了机制可以提高并发性能同时保证数据的一致性可扩展性的设计考虑了可扩展性可以处理大量数据的并发访问的缺点额外开销的实现需要维护元素的序列号和锁机制这会带来一定的额外开销写操作的延迟由于写操作需要获取锁来保证原子性可能会导致其他线程在写操作完成之前无法进行写操作的使用示例下面是一个使用的简单示例添加元素获取元素输出遍历元素输出在上面的示例中我们使用了来创建一个有序的线程安全的集合我们可以使用方法添加元素使用方法获取元素使用方法遍历元素的其他注意事项是标准库的一部分从开始引入提供了多种集合类型如等可以与其他集合类如等一起使用以满足不同的需求总结是中的一个新特性它提供了一种有序的线程安全的集合实现它通过使用机制来保证线程安全性和并发性能具有高效性能可扩展性等优点但也存在额外开销和写操作延迟的缺点在使用时我们可以创建等集合类型并使用等方法来操作集合中的数据什么是是一种用于虚拟机的垃圾回收器它是项目中的一个特性旨在提供低延迟和高吞吐量的垃圾回收解决方案为什么需要传统的垃圾回收器在处理大型堆内存时可能会导致长时间的停顿这对于需要快速响应和低延迟的应用程序来说是不可接受的的目标是减少这些停顿时间并且能够处理非常大的堆内存的实现原理基于分代垃圾回收的概念将堆内存划分为多个代其中包括年轻代和老年代具体的实现原理如下年轻代年轻代使用了的概念将整个年轻代划分为多个大小相等的区域每个区域都有一个指针指向下一个可用的区域形成一个链表结构当对象被创建时它们首先被分配到年轻代的某个区域中当一个区域被填满时会触发一次年轻代垃圾回收使用了并行和压缩算法来回收不再使用的对象老年代老年代是存放生命周期较长的对象的区域当一个对象在年轻代经历了多次垃圾回收后仍然存活它将被晋升到老年代当老年代空间不足时会触发一次老年代垃圾回收使用了并发标记和并行清理算法来回收不再使用的对象并发处理采用了并发处理的方式来减少停顿时间具体包括年轻代垃圾回收过程中应用程序可以继续执行在老年代垃圾回收过程中应用程序也可以继续执行只有在最后的清理阶段才会产生短暂的停顿的优点低延迟通过并发处理和分代回收的策略实现了非常低的停顿时间适合对响应时间要求高的应用场景高吞吐量在尽可能减少停顿时间的同时也能保持较高的垃圾回收吞吐量大堆支持可以处理非常大的堆内存适用于需要大内存容量的应用程序的缺点性能开销由于并发处理和分代回收的策略会带来一定的性能开销这主要体现在和内存的使用上配置复杂有一些与性能相关的配置参数需要根据具体场景进行调整对于不熟悉的用户来说可能比较复杂的使用示例以下是一个简单的代码示例展示了如何启用的使用注意事项是项目中的新特性虽然已经相当稳定但仍然建议在生产环境中进行充分测试在使用时建议监控系统资源使用情况以便及时调整配置参数或采取其他措施来优化性能总结是一种用于虚拟机的垃圾回收器旨在提供低延迟和高吞吐量的垃圾回收解决方案它通过并发处理和分代回收的策略实现了非常低的停顿时间并且能够处理非常大的堆内存然而使用需要注意性能开销和配置复杂性什么是是中引入的一个新特性它允许我们在模式匹配中使用记录类型记录类型是一种新的类声明形式用于定义不可变的数据对象而则提供了一种简洁的方式来进行模式匹配并且可以方便地从记录类型中提取字段值为什么需要在传统的编程中当我们需要对某个对象的属性进行判断和提取时通常需要手动编写大量的代码来完成这些操作而引入可以极大地简化这个过程使得代码更加清晰简洁并且减少了出错的可能性的实现原理的实现原理主要涉及两个方面记录类型和模式匹配记录类型记录类型是一种新的类声明形式通过关键字来定义它自动提供了以下功能自动生成私有字段并根据构造函数参数初始化这些字段自动生成和方法提供了一种紧凑的语法来定义字段和构造函数模式匹配模式匹配是指根据给定的模式来匹配某个对象并执行相应的操作在中我们可以使用关键字和模式变量来进行模式匹配具体地说当我们使用进行模式匹配时编译器会自动为记录类型生成一个模式匹配方法这个方法接受一个对象作为参数并根据给定的模式进行匹配如果匹配成功则将字段值绑定到相应的模式变量中从而可以在后续代码中使用的优点带来了以下几个优点简洁性使用可以大大简化对记录类型的模式匹配操作减少冗余代码可读性提供了一种直观清晰的语法使得代码更易于理解和维护安全性由于自动生成了和方法可以避免手动实现这些方法时可能出现的错误提高开发效率可以减少重复劳动提高开发效率的缺点尽管带来了很多好处但也存在一些限制和缺点不可变性记录类型是不可变的即字段值不能被修改这意味着如果需要修改某个字段的值就必须创建一个新的记录对象局限性目前只能用于记录类型不能用于其他类兼容性由于是在中引入的新特性因此需要使用或更高版本才能使用的使用示例下面是一个简单的示例展示了如何使用进行模式匹配输出输出在上述示例中我们定义了一个名为的记录类型并创建了一个对象然后我们使用进行模式匹配将字段值绑定到模式变量中并输出字段值的使用注意事项在使用时需要注意以下几点记录类型的字段默认是的即不能被修改如果需要修改某个字段的值就必须创建一个新的记录对象记录类型的构造函数参数和字段名称要一致否则会导致编译错误模式匹配方法的命名规则是例如总结是引入的一个新特性它提供了一种简洁清晰的方式来进行模式匹配并且可以方便地从记录类型中提取字段值使用可以使代码更加简洁可读并提高开发效率然而由于记录类型是不可变的因此在修改字段值时需要创建新的对象同时目前只能用于记录类型不能用于其他类什么是是中引入的一个新特性它允许在语句中使用模式匹配通过这个特性我们可以更方便地对变量进行类型判断和提取为什么需要在之前的版本中如果我们想要根据不同的类型执行不同的逻辑通常需要使用多个或者来进行判断这样的代码结构比较冗长并且容易出错而的引入使得我们能够更简洁清晰地处理这种情况的实现原理的实现原理主要涉及两个方面模式匹配和类型推断模式匹配模式匹配是指将某个值与一系列模式进行比较以确定是否匹配在中我们可以使用关键字后跟上模式来进行匹配例如在上述代码中和就是模式它们分别用于匹配字符串和整数类型的对象类型推断类型推断是指根据上下文信息自动推断出某个表达式的类型在中我们可以使用关键字来进行类型推断例如在上述代码中关键字用于推断的类型为的优点简化了对变量类型的判断和提取逻辑使代码更加简洁清晰减少了重复的代码提高了开发效率增强了代码的可读性和可维护性的缺点只能用于语句中不能直接用于结构目前只支持基本数据类型和引用类型的模式匹配不支持其他特殊类型如枚举数组等的模式匹配的使用示例下面是一个使用的示例代码在上述代码中根据传入的对象类型不同会执行相应的逻辑的使用注意事项模式匹配是按照的顺序进行匹配的因此需要将更具体的模式放在前面如果没有匹配到任何模式则会执行分支的逻辑在一个块内部每个模式只能出现一次否则会编译报错总结是中引入的一个新特性它允许在语句中使用模式匹配通过这个特性我们可以更方便地对变量进行类型判断和提取它简化了对变量类型的判断和提取逻辑使代码更加简洁清晰并且增强了代码的可读性和可维护性但需要注意的是目前只支持基本数据类型和引用类型的模式匹配不支持其他特殊类型的模式匹配什么是是平台的一个功能它允许开发者直接与本地代码进行交互并且可以在中操作本地内存这个功能最初在的时候以的形式引入了第一次预览版然后在中进一步改进并发布了第二次预览版现在在中发布了第三次预览版为什么需要的出现主要是为了解决以下几个问题与本地代码的无缝集成有些场景下我们可能需要调用本地库或者系统级别的函数例如使用硬件加速调用底层操作系统的特定功能等而可以使得程序能够直接调用本地函数从而实现与本地代码的无缝集成提高性能通过直接操作本地内存可以避免数据拷贝和类型转换带来的性能损耗从而提高程序的执行效率扩展现有库的功能提供了一种机制可以将本地库中的函数包装成接口从而方便地扩展现有的库的功能的实现原理的实现主要依赖于以下几个关键技术是平台提供的一种机制用于在程序中调用本地代码利用提供的能力使得程序可以直接调用本地函数内存管理允许开发者直接操作本地内存包括分配释放和读写等操作这需要对内存进行有效的管理以确保安全性和可靠性类型映射由于和本地代码使用不同的数据类型表示数据因此需要进行类型映射提供了一套规则和工具用于将类型与本地类型进行转换的优点无缝集成可以使得程序能够直接调用本地函数从而实现与本地代码的无缝集成高性能通过直接操作本地内存避免了数据拷贝和类型转换带来的性能损耗从而提高程序的执行效率灵活性提供了丰富的功能和灵活的接口可以满足不同场景下的需求的缺点安全性风险直接操作本地内存可能会带来一些安全风险例如内存泄漏访问非法内存等因此在使用时需要谨慎处理并遵循相关的安全规范复杂性涉及到与本地代码的交互和内存管理等复杂的问题对开发者的要求较高需要具备一定的底层编程知识和经验的使用示例以下是一个简单的示例展示了如何使用调用本地函数上述示例中我们使用调用了本地的函数并将结果打印出来的使用注意事项在使用时需要确保本地函数和库已经正确安装并可用对于直接操作本地内存的情况需要特别注意内存管理和安全性问题避免出现内存泄漏访问非法内存等问题使用需要谨慎处理异常以确保程序的稳定性和可靠性总结是平台提供的一种机制可以使得程序能够直接调用本地函数并且可以在中操作本地内存它通过技术实现与本地代码的无缝集成并提供了高性能和灵活性然而在使用时需要注意安全性和复杂性等问题以确保程序的稳定性和可靠性什么是是编程语言的一个新特性它在中引入并在中作为预览功能继续存在该特性允许我们使用匿名模式和变量来简化代码并提高可读性为什么需要在传统的代码中当我们需要对某个对象进行模式匹配时通常需要创建一个临时变量来存储匹配结果这样会导致代码冗长可读性差并且增加了不必要的命名负担而的出现正是为了解决这个问题通过使用匿名模式和变量我们可以直接在模式匹配表达式中使用避免了创建临时变量的麻烦使得代码更加简洁和易于理解的实现原理的实现原理主要涉及两个方面匿名模式和匿名变量匿名模式匿名模式是一种特殊的模式用于表示我们只关心某个值是否满足某个条件而不关心具体的值是什么在匿名模式中我们使用下划线来代替具体的变量名例如我们可以使用匿名模式来判断一个对象是否为匿名变量匿名变量是一种特殊的变量用于表示我们不需要使用该变量的值在匿名变量中我们同样使用下划线来代替具体的变量名例如在语句中我们可以使用匿名变量来忽略某些分支的返回值的优点简化代码通过使用匿名模式和变量可以减少临时变量的创建使得代码更加简洁提高可读性匿名模式和变量能够直接表达我们关心的条件避免了命名的繁琐使得代码更易于理解的缺点由于目前仍处于预览阶段因此存在以下一些限制和潜在问题兼容性问题由于该特性是在中引入的并且仍处于预览阶段因此可能存在与旧版本不兼容的问题语法限制匿名模式和变量只能用于某些特定的上下文中不能在所有地方使用例如在表达式方法引用等场景中暂时还无法使用的使用示例以下是一个使用匿名模式和变量的示例代码用于判断一个对象是否为非空字符串的使用注意事项在使用时需要注意以下几点匿名模式和变量只能用于表示我们不关心具体值的情况如果需要获取具体的值则应该使用普通的命名模式和变量在一些特殊的上下文中如表达式方法引用等目前还无法使用匿名模式和变量总结是编程语言的一个新特性它通过引入匿名模式和变量来简化代码并提高可读性虽然该特性目前仍处于预览阶段并存在一些限制和潜在问题但它为我们编写更简洁易读的代码提供了一种新的方式什么是虚拟线程是平台的一项新功能它旨在改进中的并发编程模型传统上使用基于操作系统线程的并发模型每个线程都需要分配一个操作系统线程来执行而则提供了一种更高效更轻量级的线程模型为什么需要在传统的基于操作系统线程的并发模型中创建和销毁线程以及在线程之间切换的开销很大这限制了应用程序在处理大规模并发时的性能和扩展性此外由于操作系统线程的数量有限当应用程序需要创建大量线程时可能会导致资源耗尽或者性能下降的出现解决了这些问题它通过引入一种轻量级的线程模型可以在应用程序中创建数百万甚至数十亿个线程而不会受到操作系统线程数量的限制这使得应用程序能够更好地适应大规模并发场景并提供更高的性能和可伸缩性的实现原理的实现依赖于虚拟机的协作调度器和框架它通过将多个映射到少量的操作系统线程上来实现高效的并发执行具体而言当一个应用程序创建一个时会为其分配一个虚拟线程也称为轻量级线程这些虚拟线程由协作调度器管理并在需要时与操作系统线程进行绑定协作调度器负责决定哪个虚拟线程可以运行以及何时切换虚拟线程框架是的另一个关键组件它提供了一种任务并行编程模型允许开发人员将任务分解成更小的子任务并使用工作窃取算法来实现负载均衡利用框架的能力在不同的虚拟线程之间自动地透明地进行任务划分和调度的优点更高的性能减少了线程创建和销毁的开销同时避免了操作系统线程数量的限制从而提供更高的性能更好的可伸缩性由于可以创建数百万甚至数十亿个线程因此应用程序可以更好地适应大规模并发场景并具有更好的可伸缩性更低的资源消耗相比于操作系统线程是轻量级的占用更少的内存和资源的缺点虽然带来了许多优势但也存在一些潜在的缺点学习成本较高使用需要对并发编程模型有一定的理解并且需要适应新的和开发范式可能引入新的问题由于是一个相对较新的功能可能会存在一些未知的问题或者不稳定性的使用示例下面是一个简单的使用的示例代码上述示例中我们使用方法创建了一个实例该实例可以执行然后我们通过调用方法提交了一系列任务每个任务都会打印当前运行的虚拟线程的名称的使用注意事项在使用时需要注意以下几点虽然可以创建大量线程但过多的线程仍可能导致性能下降或资源耗尽因此在设计应用程序时仍需合理控制并发度使用时需要遵循良好的并发编程实践如避免共享可变状态使用适当的同步机制等以确保线程安全性和正确性在迁移现有代码到使用时需要进行一定的重构和调整以适应新的和开发范式总结是平台的一项新功能旨在改进中的并发编程模型它通过引入轻量级的虚拟线程并利用协作调度器和框架来提供高效的并发执行具有更高的性能更好的可伸缩性和较低的资源消耗但也需要学习成本较高并且可能存在一些潜在的问题在使用时需要注意合理控制并发度遵循并发编程实践并进行必要的重构和调整什么是是一个编程语言的新特性它在中引入并在中成为预览功能该特性允许我们在类中定义匿名类和实例主方法在传统的编程中我们只能在顶级类或静态内部类中定义方法作为程序的入口点而使用特性后我们可以在任何类的实例中定义方法从而使得程序的入口点更加灵活为什么需要传统的程序必须将方法定义在顶级类或静态内部类中这限制了程序的结构和组织方式有时候我们可能希望将多个相关的逻辑封装在同一个类的实例中以提高代码的可读性和可维护性而特性正是为了满足这种需求而引入的通过在类的实例中定义方法我们可以更好地组织和管理程序的逻辑减少顶级类和静态内部类的数量使代码更加清晰和易于理解的实现原理特性的实现原理涉及到两个方面匿名类和实例主方法匿名类在中我们可以使用匿名类来创建一个没有显式名称的类匿名类通常用于创建临时的只需要一次使用的类对象它们可以继承自某个类或实现某个接口并重写其中的方法匿名类的语法如下父类构造器参数列表匿名类的成员变量和方法定义实例主方法传统的程序入口点是通过静态方法来定义的而特性允许我们在类的实例中定义方法实例主方法的语法如下主方法的代码逻辑的优点灵活性通过在类的实例中定义方法程序的入口点更加灵活可以根据需求将多个相关的逻辑封装在同一个类的实例中可读性将相关的逻辑组织在同一个类的实例中使得代码更加清晰和易于理解可维护性减少顶级类和静态内部类的数量简化代码结构提高代码的可维护性的缺点语法复杂匿名类和实例主方法的语法相对传统的方法更加复杂需要额外的学习成本可读性降低如果滥用该特性将多个逻辑封装在同一个类的实例中可能会导致代码可读性下降的使用示例下面是一个使用特性的示例在上述示例中我们定义了一个名为的类并在其中创建了一个实例通过调用实例的方法程序的入口点被指定为该实例的方法的使用注意事项在使用特性时需要确保每个类的实例只有一个方法否则编译器将无法确定程序的入口点匿名类和实例主方法的语法较为复杂需要仔细理解并遵循正确的语法规则虽然特性在中成为预览功能但仍然存在一些潜在的问题和限制在使用时需要注意这些问题并及时反馈给开发团队总结是编程语言的一个新特性它允许我们在类的实例中定义匿名类和实例主方法通过该特性我们可以更灵活地组织程序的逻辑提高代码的可读性和可维护性然而使用该特性需要注意语法复杂性和可读性降低的问题并遵循正确的使用方式什么是是平台的一个新特性它在中引入该特性旨在提供一种机制用于在代码块级别上设置和使用临时变量为什么需要在传统的编程中我们通常会将变量声明在方法或类的作用域内并且这些变量的生命周期与其所在的作用域相同然而在某些情况下我们可能希望在更小的范围内定义临时变量以便更好地控制其可见性和生命周期提供了一种简洁安全的方式来定义和使用临时变量使得代码更加清晰易读并且可以减少不必要的命名冲突和资源泄漏问题的实现原理的实现基于语言规范中的局部变量类型推断机制通过使用关键字我们可以在代码块内部声明临时变量并根据初始化表达式的类型进行类型推断例如以下示例展示了如何使用声明和使用临时变量使用声明临时变量在代码块内部使用临时变量在上述示例中我们使用声明了一个名为的临时变量并将其初始化为字符串然后在语句的代码块内部我们可以直接使用该临时变量的优点简洁性提供了一种更简洁的方式来声明和使用临时变量减少了冗余的代码可读性通过在代码块级别上定义临时变量使得代码更加清晰易读提高了代码的可维护性类型安全基于语言规范中的局部变量类型推断机制确保了变量的类型安全性的缺点尽管提供了许多优点但也存在一些潜在的缺点兼容性问题由于是中引入的新特性因此在较旧版本的中无法使用学习成本对于不熟悉局部变量类型推断机制的开发人员来说可能需要一些时间来适应的使用方式的使用示例以下是一个使用的简单示例在上述示例中我们使用声明了一个名为的临时变量并将其初始化为字符串然后我们通过调用方法打印该临时变量的值的使用注意事项在使用时需要注意以下几点作用域限制声明的临时变量仅在当前代码块内部可见超出该代码块范围后将无法访问类型推断由于是基于局部变量类型推断机制实现的因此必须确保初始化表达式具有明确的类型信息以便进行正确的类型推断命名冲突当在同一代码块内使用多个声明临时变量时需要避免命名冲突以免引起混淆和错误总结是平台的一个新特性它提供了一种在代码块级别上设置和使用临时变量的机制通过使用关键字我们可以在代码块内部声明临时变量并根据初始化表达式的类型进行类型推断的优点包括简洁性可读性和类型安全性但也存在兼容性问题和学习成本在使用时需要注意作用域限制类型推断和命名冲突等注意事项什么是是平台的一个项目旨在提供一种简单且高效的方式来执行向量化计算它引入了新的类和接口以支持使用指令集进行并行计算为什么需要在许多应用程序中存在大量的数据并行计算任务例如图像处理科学计算和机器学习等领域传统的编程模型无法充分利用现代硬件的并行计算能力导致性能低下而的目标就是通过向量化计算来提高这些应用程序的性能的实现原理基于指令集即单指令多数据流指令集指令集可以同时对多个数据元素执行相同的操作从而实现并行计算提供了一组新的类和接口使开发人员能够直接编写基于指令集的代码具体来说引入了包其中包含了一些新的类和接口如和等这些类提供了一组向量化操作方法例如加法减法乘法等以及对应的掩码操作在底层实现上使用了特定硬件平台的指令集来执行向量化计算具体实现细节会依赖于不同的硬件架构和操作系统的优点提高性能通过利用指令集进行并行计算可以显著提高应用程序的性能简化编程模型提供了一组简单易用的类和接口使开发人员能够直接编写基于指令集的代码而无需手动优化的缺点平台限制的实现依赖于特定的硬件平台和操作系统因此在不同的平台上可能存在兼容性问题学习成本使用需要学习新的类和接口并理解指令集的工作原理对于一些开发人员来说可能需要花费一定的时间和精力的使用示例下面是一个简单的使用进行向量化计算的示例创建两个向量对象执行向量化加法操作输出结果在上述示例中我们创建了两个长度为的浮点数向量并执行了向量化的加法操作最后将结果输出到数组中并打印出来的使用注意事项硬件兼容性由于的实现依赖于特定的硬件平台和操作系统因此在使用之前需要确保目标平台支持指令集性能优化虽然可以提高应用程序的性能但要获得最佳性能还需要进行适当的优化例如避免频繁的向量化操作和数据拷贝等总结是平台的一个项目旨在提供一种简单且高效的方式来执行向量化计算它基于指令集并通过引入新的类和接口来支持并行计算使用可以提高应用程序的性能但需要注意硬件兼容性和适当的性能优化名字太长了后面简称什么是是一个针对的提案旨在废弃并最终移除位平台上的支持为什么需要废弃位平台上的支持主要有以下几个原因过时的硬件和操作系统位平台已经逐渐被淘汰现代计算机普遍采用位架构同时大多数新版本的操作系统也只提供了位版本性能限制位架构限制了可寻址内存空间的大小导致无法充分利用现代计算机的资源而位架构可以提供更大的内存地址空间从而提高应用程序的性能和扩展性安全问题位架构存在一些安全漏洞和限制例如缓冲区溢出等而位架构通过引入更多的保护机制来增加应用程序的安全性基于以上原因废弃位平台上的支持是合理且必要的的实现原理的实现原理涉及到编译器虚拟机和库等多个方面的改动编译器层面废弃位平台上的支持需要对编译器进行修改禁止生成位架构的目标代码虚拟机层面虚拟机需要对内存管理垃圾回收等进行调整以适应位架构的特性同时还需要更新与操作系统交互的部分代码确保在位环境下正常运行库层面一些与硬件相关的库可能需要重新编写或者替换为位版本以充分利用位架构的优势具体实现细节可以参考提案中的详细说明的优点性能提升位架构可以提供更大的内存地址空间从而提高应用程序的性能和扩展性安全增强位架构引入了更多的保护机制提高了应用程序的安全性与现代计算机趋势相符位平台已经逐渐被淘汰废弃该平台上的支持是与时俱进的举措的缺点向后兼容性问题废弃位平台上的支持可能导致一些现有的应用程序无法在该平台上运行这需要开发人员进行相应的迁移和调整对于仍然使用位硬件和操作系统的用户而言将无法继续获得新版本的更新和功能改进的使用示例是一个的提案它主要影响到的开发者和位平台上的用户对于开发者来说他们需要根据的实施情况适时地迁移和调整自己的应用程序代码对于位平台上的用户来说他们需要考虑升级到位架构的计算机和操作系统以继续获得最新的更新和功能改进的使用注意事项开发者需要及时关注的实施情况并根据需要进行相应的迁移和调整位平台上的用户需要考虑升级到位架构的计算机和操作系统以继续获得最新的更新和功能改进总结旨在废弃并最终移除位平台上的支持这是基于该平台已经逐渐被淘汰性能限制和安全问题等原因做出的合理举措废弃该平台上的支持可以提高应用程序的性能和安全性并与现代计算机趋势相符开发者需要及时关注的实施情况并根据需要进行相应的迁移和调整位平台上的用户需要考虑升级到位架构的计算机和操作系统以继续获得最新的更新和功能改进什么是动态加载代理禁用准备动态加载代理禁用准备是一个增强提案其目标是在中禁止动态加载代理代理是一种能够修改或监视应用程序行为的机制它可以通过字节码注入来实现为什么需要动态加载代理禁用准备动态加载代理允许开发人员在运行时修改和监视应用程序的行为虽然这对于调试和性能分析等方面非常有用但也存在潜在的安全风险恶意代码可能会利用动态加载代理的功能来执行恶意操作例如窃取敏感信息篡改数据等因此为了加强应用程序的安全性限制动态加载代理的使用是很有必要的动态加载代理禁用准备的实现原理动态加载代理禁用准备的实现涉及到以下几个方面修改该提案建议修改虚拟机的类加载器以阻止动态加载代理具体而言将在类中添加一个新的方法默认返回当该方法被调用时将返回表示禁止动态加载代理修改为了支持的修改还需要对虚拟机的进行相应的更改具体而言将在接口中添加一个新的方法默认返回当该方法返回时表示禁止动态加载代理更新安全管理器此外还建议更新虚拟机的安全管理器以允许检查是否允许动态加载代理这样可以通过安全策略来控制哪些代码可以使用动态加载代理功能动态加载代理禁用准备的优点提高应用程序的安全性禁止动态加载代理可以防止恶意代码利用其功能执行潜在的危险操作简化安全配置通过更新安全管理器和类加载器可以更方便地控制动态加载代理的使用权限简化安全配置过程动态加载代理禁用准备的缺点可能影响现有代码如果现有代码依赖于动态加载代理的功能那么禁用它可能会导致这些代码无法正常工作因此在应用该增强提案之前需要仔细评估现有代码的依赖关系动态加载代理禁用准备的使用示例以下是一个简单的示例展示了如何使用动态加载代理禁用准备禁止动态加载代理其他初始化操作在上述示例中方法是代理的入口点通过调用方法可以检查是否允许动态加载代理如果不允许则抛出安全异常动态加载代理禁用准备的使用注意事项在使用动态加载代理禁用准备之前需要仔细评估现有代码是否依赖于动态加载代理的功能需要更新相关的类加载器和安全管理器来支持禁止动态加载代理的功能使用动态加载代理禁用准备时需要确保应用程序的安全策略能够正确地控制动态加载代理的使用权限总结动态加载代理禁用准备是一个增强提案旨在禁止动态加载代理以提高应用程序的安全性它通过修改类加载器和安全管理器来实现禁止动态加载代理的功能尽管这样做可以增加应用程序的安全性但也可能影响依赖于动态加载代理的现有代码因此在使用该功能之前需要仔细评估现有代码的依赖关系什么是是一个用于支持密钥封装机制密钥封装是一种加密技术它将一个对称密钥也称为会话密钥与公钥结合使用以便在不直接暴露私钥的情况下安全地传输密钥提供了一组方法和类用于生成封装和解封装密钥它可以与现有的密码学算法和协议集成提供更高级别的密钥管理功能为什么需要在传统的密钥交换过程中通常需要事先共享或分发密钥这可能存在许多安全风险例如密钥泄露中间人攻击等而密钥封装机制通过使用公钥进行密钥交换避免了这些问题的出现使得开发者能够更方便地实现密钥封装机制并提供了更高级别的密钥管理功能它简化了密钥生成封装和解封装的过程同时保证了安全性和可靠性的实现原理的实现原理基于非对称加密算法和密钥封装机制它使用公钥进行密钥交换并通过将会话密钥封装在一个安全的密文中以确保密钥的安全传输具体实现过程如下生成一对公私钥对使用公钥进行密钥封装生成一个密文将密文发送给接收方接收方使用私钥解封装密文得到会话密钥双方可以使用会话密钥进行加密通信的优点安全性高使用了非对称加密算法和密钥封装机制能够提供较高的安全性避免了密钥泄露和中间人攻击等问题易于使用提供了简单易用的方法和类开发者可以轻松地生成封装和解封装密钥无需深入了解底层算法和协议灵活性强可以与现有的密码学算法和协议集成提供更高级别的密钥管理功能满足不同场景的需求的缺点依赖于非对称加密算法的实现依赖于非对称加密算法这些算法可能存在性能上的瓶颈和限制需要保护私钥的安全由于使用了非对称加密算法私钥的安全至关重要开发者需要采取措施来保护私钥的机密性和完整性的使用示例下面是一个简单的使用示例演示了如何使用进行密钥封装和解封装生成公私钥对创建对象执行密钥协商过程生成会话密钥封装会话密钥解封装会话密钥输出结果的使用注意事项开发者需要选择合适的非对称加密算法和密钥封装机制根据具体需求进行配置私钥的安全至关重要开发者应该采取措施来保护私钥的机密性和完整性密钥封装过程中生成的密文需要通过安全信道传输以确保密钥的安全性总结是一个用于支持密钥封装机制的它提供了一组方法和类用于生成封装和解封装密钥通过使用公钥进行密钥交换避免了传统密钥交换方式中存在的安全风险的实现原理基于非对称加密算法和密钥封装机制能够提供较高的安全性和灵活性开发者可以轻松地使用进行密钥封装和解封装操作并与现有的密码学算法和协议集成满足不同场景的需求然而的使用需要注意私钥的安全性和密文的传输安全什么是结构化并发结构化并发是一种用于简化并发编程的它将在不同线程中运行的相关任务组视为一个单独的工作单元从而简化错误处理和取消操作提高可靠性并增强可观察性为什么需要结构化并发传统的并发编程模型如由于其无限制的并发模式引入了复杂性和风险这些模型没有强制执行或跟踪任务和子任务之间的关系使得管理和观察并发任务变得困难结构化并发模型认为任务结构应该反映代码结构在单线程代码中执行总是强制实施任务和子任务的层次结构每个子任务的生命周期相对于其他子任务受到代码的语法块结构的控制结构化并发旨在消除与并发编程相关的常见风险例如线程泄漏和取消延迟并增强并发代码的可观察性结构化并发的实现原理结构化并发通过引入新的来实现其中最重要的类是封装了一组相关的任务这些任务应该一起完成如果任何子任务失败则会取消剩余的子任务在结构化并发中使用创建一个作用域在该作用域内可以派生出多个子任务这些子任务将被视为整体并且它们之间存在依赖关系当所有子任务完成后可以对它们进行处理例如获取结果或抛出异常结构化并发的优点简化并发编程结构化并发提供了一种更简单更直观的方式来处理并发任务错误处理和取消操作通过将相关任务组合成一个单元结构化并发使错误处理和取消操作更加容易和可靠提高可靠性结构化并发模型消除了常见的风险如线程泄漏和取消延迟从而提高了并发代码的可靠性增强可观察性结构化并发模型使得观察并发任务的执行状态变得更加方便结构化并发的缺点预览功能目前结构化并发仍处于预览阶段需要启用预览功能才能使用结构化并发的使用示例下面是一个使用结构化并发的示例代码在这个示例中我们创建了一个新的作用域并使用它派生了两个子任务一个执行方法另一个执行方法一旦两个子任务都完成就可以使用它们的结果创建一个新的对象结构化并发的使用注意事项结构化并发是一个预览功能默认情况下被禁用要使用开发人员必须启用预览功能来编译代码使用结构化并发时通常不直接使用类而是使用实现关闭策略的两个子类之一这些子类分别是和支持当第一个子任务失败或成功时关闭作用域的模式运行结构化并发程序时需要使用选项启用预览功能总结结构化并发是一种用于简化并发编程的它将相关任务组合成一个单元从而简化错误处理和取消操作提高可靠性并增强可观察性通过引入类和相关的子类结构化并发提供了一种更简单更直观的方式来处理并发任务然而需要注意的是结构化并发目前仍处于预览阶段并且需要启用预览功能才能使用将是大多数供应商的长期支持版本有关自上一个版本以来集成的的完整列表请参阅第一阶段缓慢降级从主分支派生第二阶段缓慢降级初始候选发行版最终候选发行版正式发布最后更新时间年月日程序员朱永胜',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-22 07:04:44',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="atom.xml" title="" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.zysicyj.top/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2748ef34.jpg" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">写作软件</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://editor.runjs.cool/post?id=demo" title="Mdx"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4296739868700.png" alt="Mdx"/><span class="back-menu-item-text">Mdx</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://openwrite.cn/" title="OpenWrite"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://openwrite.cn/logo.png" alt="OpenWrite"/><span class="back-menu-item-text">OpenWrite</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jetbrains.com/zh-cn/writerside/" title="WriteSide"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="data:image/jpeg;base64,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" alt="WriteSide"/><span class="back-menu-item-text">WriteSide</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">开发工具</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jetbrains.com/zh-cn/idea/" title="idea"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4576710485000.png" alt="idea"/><span class="back-menu-item-text">idea</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jetbrains.com/zh-cn/datagrip/" title="DataGrip"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4604435065400.png" alt="DataGrip"/><span class="back-menu-item-text">DataGrip</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4663369180700.png" title="WebStorm"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4604435065400.png" alt="WebStorm"/><span class="back-menu-item-text">WebStorm</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" title="微信开发者工具"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4743988475500.png" alt="微信开发者工具"/><span class="back-menu-item-text">微信开发者工具</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" title="HBuilder"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.dcloud.io/hbuilderx.html" alt="HBuilder"/><span class="back-menu-item-text">HBuilder</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://mobaxterm.mobatek.net/" title="MobaXterm"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4849682167700.png" alt="MobaXterm"/><span class="back-menu-item-text">MobaXterm</span></a></div></div></div></div><a id="site-name" href="index.html" accesskey="h"><div class="title"></div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)" rel="external nofollow noreferrer">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="index.html"><i class="fas fa-home faa-tada"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-link faa-tada"></i><span> 目录</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fas fa-archive faa-tada"></i><span> 时间轴</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fas fa-folder-open faa-tada"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-list faa-tada"></i><span> 清单</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="fas fa-video faa-tada"></i><span> 电影</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/books/"><i class="fas fa-book faa-tada"></i><span> 阅读</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/songs/"><i class="fas fa-music faa-tada"></i><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="fa-brands fa-bilibili faa-tada"></i><span> 追番</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cinemas/"><i class="fa-brands fa-bilibili faa-tada"></i><span> 追剧</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="fas fa-link faa-tada"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fas fa-solid fa-image faa-tada"></i><span> 相册集</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/love/static/index.html"><i class="fas fa-heart faa-tada"></i><span> Love</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="fa-solid fa-user faa-tada"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="fa-solid  fa-comment faa-tada"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142337659.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="wechat" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142337659.png"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142338230.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" alt="alipay" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142338230.png"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="tags/2024%E5%B9%B4/" style="font-size: 1.05rem;">2024年<sup>1</sup></a><a href="tags/2024%E5%B9%B47%E6%9C%88/" style="font-size: 1.05rem;">2024年7月<sup>1</sup></a><a href="tags/2%E6%97%A5/" style="font-size: 1.05rem;">2日<sup>1</sup></a><a href="tags/7%E6%9C%88/" style="font-size: 1.05rem;">7月<sup>1</sup></a><a href="tags/Butterfly/" style="font-size: 1.05rem;">Butterfly<sup>2</sup></a><a href="tags/CSS/" style="font-size: 1.05rem;">CSS<sup>2</sup></a><a href="tags/Docker-Compose%E5%AE%89%E8%A3%85Space/" style="font-size: 1.05rem;">Docker Compose安装Space<sup>1</sup></a><a href="tags/GithubPages/" style="font-size: 1.05rem;">GithubPages<sup>3</sup></a><a href="tags/Github%E9%85%8D%E7%BD%AE/" style="font-size: 1.05rem;">Github配置<sup>2</sup></a><a href="tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>7</sup></a><a href="tags/NR/" style="font-size: 1.05rem;">NR<sup>8</sup></a><a href="tags/Redis%E9%9B%86%E7%BE%A4/" style="font-size: 1.05rem;">Redis集群<sup>1</sup></a><a href="tags/github/" style="font-size: 1.05rem;">github<sup>1</sup></a><a href="tags/gossip%E5%8D%8F%E8%AE%AE/" style="font-size: 1.05rem;">gossip协议<sup>1</sup></a><a href="tags/hexo/" style="font-size: 1.05rem;">hexo<sup>1</sup></a><a href="tags/nari/" style="font-size: 1.05rem;">nari<sup>22</sup></a><a href="tags/xxc/" style="font-size: 1.05rem;">xxc<sup>1</sup></a><a href="tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">个人博客<sup>2</sup></a><a href="tags/%E5%85%8D%E8%B4%B9/" style="font-size: 1.05rem;">免费<sup>2</sup></a><a href="tags/%E5%85%8D%E8%B4%B9%E6%9C%8D%E5%8A%A1/" style="font-size: 1.05rem;">免费服务<sup>1</sup></a><a href="tags/%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 1.05rem;">内存数据库<sup>1</sup></a><a href="tags/%E5%8D%95%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">单线程<sup>1</sup></a><a href="tags/%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/" style="font-size: 1.05rem;">发布文章<sup>2</sup></a><a href="tags/%E5%95%86%E5%93%81/" style="font-size: 1.05rem;">商品<sup>9</sup></a><a href="tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" style="font-size: 1.05rem;">多路复用<sup>1</sup></a><a href="tags/%E5%AE%89%E8%A3%85Hexo/" style="font-size: 1.05rem;">安装Hexo<sup>2</sup></a><a href="tags/%E6%90%AD%E5%BB%BA/" style="font-size: 1.05rem;">搭建<sup>2</sup></a><a href="tags/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/" style="font-size: 1.05rem;">数据同步<sup>1</sup></a><a href="tags/%E6%97%A5%E8%AE%B0/" style="font-size: 1.05rem;">日记<sup>14</sup></a><a href="tags/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97/" style="font-size: 1.05rem;">更新日志<sup>10</sup></a><a href="tags/%E6%A7%BD%E5%88%86%E9%85%8D/" style="font-size: 1.05rem;">槽分配<sup>1</sup></a><a href="tags/%E7%9F%A5%E5%90%8D%E9%A1%B9%E7%9B%AE-Redis/" style="font-size: 1.05rem;">知名项目/Redis<sup>1</sup></a><a href="tags/%E7%BD%91%E7%AB%99/" style="font-size: 1.05rem;">网站<sup>2</sup></a><a href="tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/" style="font-size: 1.05rem;">网站搭建<sup>1</sup></a><a href="tags/%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1/" style="font-size: 1.05rem;">节点通信<sup>1</sup></a><a href="tags/%E8%AE%BF%E9%97%AE/" style="font-size: 1.05rem;">访问<sup>2</sup></a><a href="tags/%E8%B5%84%E6%BA%90/" style="font-size: 1.05rem;">资源<sup>9</sup></a><a href="tags/%E9%85%8D%E7%BD%AEhexo-deployer-git/" style="font-size: 1.05rem;">配置hexo-deployer-git<sup>2</sup></a><a href="tags/%E9%9B%86%E7%BE%A4%E5%88%86%E7%89%87/" style="font-size: 1.05rem;">集群分片<sup>1</sup></a><a href="tags/%E9%AB%98%E6%80%A7%E8%83%BD/" style="font-size: 1.05rem;">高性能<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">66</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">27</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);" rel="external nofollow noreferrer"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a></div></div><h1 class="post-title" itemprop="name headline">JDK21 更新特性详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-09-22T14:36:11.000Z" title="发表于 2023-09-22 14:36:11">2023-09-22</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-01-22T07:04:44.389Z" title="更新于 2025-01-22 07:04:44">2025-01-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">16.4k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="JDK21 更新特性详解"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为南京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>南京</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="https://blog.zysicyj.top/752ac5dd.html"><header><h1 id="CrawlerTitle" itemprop="name headline">JDK21 更新特性详解</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">程序员朱永胜</span><time itemprop="dateCreated datePublished" datetime="2023-09-22T14:36:11.000Z" title="发表于 2023-09-22 14:36:11">2023-09-22</time><time itemprop="dateCreated datePublished" datetime="2025-01-22T07:04:44.389Z" title="更新于 2025-01-22 07:04:44">2025-01-22</time></header><div id="readmore-container"><link rel="stylesheet external nofollow noreferrer" type="text/css" href="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/css/lightgallery.min.css" /><div class=".article-gallery"><blockquote>
<p>有的时候博客内容会有变动，首发博客是最新的，其他博客地址可能会未同步, 认准<code>https://blog.zysicyj.top</code></p>
</blockquote>
<hr>
<blockquote>
<p>新特性</p>
</blockquote>
<h1 id="430-String-Templates-Preview"><a href="#430-String-Templates-Preview" class="headerlink" title="| 430: | String Templates (Preview) |"></a>| 430: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/430">String Templates (Preview)</a> |</h1><h2 id="1- 什么是 String-Templates"><a href="#1- 什么是 String-Templates" class="headerlink" title="1. 什么是 String Templates?"></a>1. 什么是 String Templates?</h2><p>String Templates 是 Java 15 中引入的一个新特性，它允许我们在字符串中使用占位符来动态替换变量的值。它提供了一种更简洁、更直观的方式来构建字符串，而不需要使用传统的字符串拼接或格式化方法。</p>
<h2 id="2- 为什么需要 String-Templates"><a href="#2- 为什么需要 String-Templates" class="headerlink" title="2. 为什么需要 String Templates?"></a>2. 为什么需要 String Templates?</h2><p>在传统的 Java 中，我们通常使用字符串拼接或格式化方法来构建动态字符串。这种方式需要手动处理变量的值，并且容易出错。而且，当字符串中包含大量变量时，代码会变得冗长且难以维护。</p>
<p>String Templates 的引入解决了这个问题，它提供了一种更简洁、更易读的方式来构建动态字符串。通过使用占位符，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。</p>
<h2 id="3-String-Templates 的实现原理"><a href="#3-String-Templates 的实现原理" class="headerlink" title="3. String Templates 的实现原理?"></a>3. String Templates 的实现原理?</h2><p>String Templates 的实现原理是通过在字符串中使用占位符 <code>$&#123;&#125;</code> 来表示变量。在运行时，Java 编译器会将这些占位符替换为实际的变量值。</p>
<p>具体来说，当我们使用 String Templates 时，编译器会将字符串中的占位符 <code>$&#123;&#125;</code><br> 解析为一个特殊的表达式，并将其转换为对应的变量值。这个过程是在编译时完成的，所以在运行时不会有额外的性能开销。</p>
<h2 id="4-String-Templates 的优点"><a href="#4-String-Templates 的优点" class="headerlink" title="4. String Templates 的优点"></a>4. String Templates 的优点</h2><ul>
<li><strong>简洁易读 </strong>：使用占位符<code>$&#123;&#125;</code> 来表示变量，使得代码更加简洁、易读。</li>
<li><strong>类型安全</strong>：String Templates 在编译时会进行类型检查，确保变量的类型与占位符的类型匹配，避免了运行时的类型错误。</li>
<li><strong>性能优化</strong>：String Templates 的解析过程是在编译时完成的，所以在运行时不会有额外的性能开销。</li>
<li><strong>可扩展性</strong>：String Templates 支持自定义的格式化函数，可以根据需求进行扩展。</li>
</ul>
<h2 id="5-String-Templates 的缺点"><a href="#5-String-Templates 的缺点" class="headerlink" title="5. String Templates 的缺点"></a>5. String Templates 的缺点</h2><ul>
<li><strong>兼容性</strong>：String Templates 是 Java 15 中引入的新特性，需要使用 Java 15 或更高版本的 JDK 才能使用。</li>
<li><strong>语法限制 </strong>：String Templates 的占位符<code>$&#123;&#125;</code> 只能用于表示变量，不能用于执行任意的表达式。</li>
<li><strong>可读性</strong>：当字符串中包含大量的占位符时，可能会降低代码的可读性。</li>
</ul>
<h2 id="6-String-Templates 的使用示例"><a href="#6-String-Templates 的使用示例" class="headerlink" title="6. String Templates 的使用示例"></a>6. String Templates 的使用示例 </h2><p> 下面是一个使用 String Templates 的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">25</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;My name is $&#123;name&#125; and I&#x27;m $&#123;age&#125; years old.&quot;</span>;</span><br><span class="line">System.out.println(message);</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">My name <span class="keyword">is</span> Alice <span class="keyword">and</span> I<span class="symbol">&#x27;m</span> <span class="number">25</span> years old.</span><br></pre></td></tr></table></figure>

<h2 id="7-String-Templates 的使用注意事项"><a href="#7-String-Templates 的使用注意事项" class="headerlink" title="7. String Templates 的使用注意事项"></a>7. String Templates 的使用注意事项</h2><ul>
<li>占位符 <code>$&#123;&#125;</code> 中的变量名必须是有效的 Java 标识符。</li>
<li>占位符 <code>$&#123;&#125;</code> 中的变量值可以是任意类型，编译器会自动进行类型转换。</li>
<li>如果变量值为 null，占位符 <code>$&#123;&#125;</code> 会被替换为字符串”null”。</li>
<li>String Templates 支持嵌套使用，可以在占位符 <code>$&#123;&#125;</code> 中使用其他占位符。</li>
</ul>
<p>特别容易卡住。。然后就喊我。。</p>
<h2 id="8- 总结"><a href="#8- 总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>String Templates 是 Java 15 中引入的一个新特性，它提供了一种更简洁、更直观的方式来构建动态字符串。通过使用占位符<code>$&#123;&#125;</code><br>，我们可以将变量的值直接嵌入到字符串中，而不需要手动处理。String<br>Templates 具有简洁易读、类型安全、性能优化和可扩展性等优点，但也存在兼容性、语法限制和可读性等缺点。在使用 String<br>Templates 时，需要注意占位符的命名规则和变量值的类型。</p>
<h1 id="431-Sequenced-Collections"><a href="#431-Sequenced-Collections" class="headerlink" title="| 431: | Sequenced Collections |"></a>| 431: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/431">Sequenced Collections</a> |</h1><h1 id="Sequenced-Collections"><a href="#Sequenced-Collections" class="headerlink" title="Sequenced Collections"></a>Sequenced Collections</h1><h2 id="1- 什么是 Sequenced-Collections？"><a href="#1- 什么是 Sequenced-Collections？" class="headerlink" title="1. 什么是 Sequenced Collections？"></a>1. 什么是 Sequenced Collections？</h2><p>Sequenced Collections 是 Java 中的一个新特性，它是通过 JEP 431 引入的。Sequenced<br>Collections 是一种新的集合类型，它提供了一种有序的、线程安全的集合实现。它的目标是提供一种高效的、可扩展的有序集合，以满足在多线程环境下处理大量数据的需求。</p>
<h2 id="2- 为什么需要 Sequenced-Collections？"><a href="#2- 为什么需要 Sequenced-Collections？" class="headerlink" title="2. 为什么需要 Sequenced Collections？"></a>2. 为什么需要 Sequenced Collections？</h2><p>在并发编程中，处理大量数据时，有序集合是非常常见的需求。然而，Java 标准库中的集合类（如 ArrayList、LinkedList 等）并不是线程安全的，因此在多线程环境下使用它们可能会导致数据不一致的问题。为了解决这个问题，开发人员通常需要使用同步机制（如 synchronized 关键字或 Lock 对象）来保证集合的线程安全性，但这会带来额外的开销和复杂性。</p>
<p>Sequenced Collections 的目标就是提供一种高效的、可扩展的有序集合，以解决在多线程环境下处理大量数据时的线程安全问题。</p>
<h2 id="3-Sequenced-Collections 的实现原理"><a href="#3-Sequenced-Collections 的实现原理" class="headerlink" title="3. Sequenced Collections 的实现原理"></a>3. Sequenced Collections 的实现原理</h2><p>Sequenced Collections 的实现基于一种称为”Sequenced Locks”的机制。Sequenced<br>Locks 是一种特殊的锁机制，它允许多个线程同时读取集合中的数据，但只允许一个线程进行写操作。这种机制可以提高并发性能，同时保证数据的一致性。</p>
<p>在 Sequenced<br>Collections 中，每个元素都有一个唯一的序列号，用于标识元素的顺序。读操作可以并发进行，而写操作则需要获取锁来保证原子性。当一个线程进行写操作时，其他线程可以继续读取集合中的数据，但不能进行写操作，直到写操作完成。</p>
<h2 id="4-Sequenced-Collections 的优点"><a href="#4-Sequenced-Collections 的优点" class="headerlink" title="4. Sequenced Collections 的优点"></a>4. Sequenced Collections 的优点</h2><ul>
<li><strong>线程安全</strong>：Sequenced Collections 提供了线程安全的集合实现，可以在多线程环境下安全地访问和修改集合中的数据。</li>
<li><strong>高效性能</strong>：Sequenced Collections 使用了 Sequenced Locks 机制，可以提高并发性能，同时保证数据的一致性。</li>
<li><strong>可扩展性</strong>：Sequenced Collections 的设计考虑了可扩展性，可以处理大量数据的并发访问。</li>
</ul>
<h2 id="5-Sequenced-Collections 的缺点"><a href="#5-Sequenced-Collections 的缺点" class="headerlink" title="5. Sequenced Collections 的缺点"></a>5. Sequenced Collections 的缺点</h2><ul>
<li><strong>额外开销</strong>：Sequenced Collections 的实现需要维护元素的序列号和锁机制，这会带来一定的额外开销。</li>
<li><strong>写操作的延迟</strong>：由于写操作需要获取锁来保证原子性，可能会导致其他线程在写操作完成之前无法进行写操作。</li>
</ul>
<h2 id="6-Sequenced-Collections 的使用示例"><a href="#6-Sequenced-Collections 的使用示例" class="headerlink" title="6. Sequenced Collections 的使用示例"></a>6. Sequenced Collections 的使用示例 </h2><p> 下面是一个使用 Sequenced Collections 的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.SequencedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SequencedCollectionsExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SequencedHashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">SequencedHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取元素</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fruit</span> <span class="operator">=</span> map.get(<span class="number">2</span>);</span><br><span class="line">        System.out.println(fruit); <span class="comment">// 输出: Banana</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历元素</span></span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(key + <span class="string">&quot;: &quot;</span> + value));</span><br><span class="line">        <span class="comment">// 输出:</span></span><br><span class="line">        <span class="comment">// 1: Apple</span></span><br><span class="line">        <span class="comment">// 2: Banana</span></span><br><span class="line">        <span class="comment">// 3: Orange</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用了 SequencedHashMap 来创建一个有序的、线程安全的集合。我们可以使用 put 方法添加元素，使用 get 方法获取元素，使用 forEach 方法遍历元素。</p>
<h2 id="7-Sequenced-Collections 的其他注意事项"><a href="#7-Sequenced-Collections 的其他注意事项" class="headerlink" title="7. Sequenced Collections 的其他注意事项"></a>7. Sequenced Collections 的其他注意事项</h2><ul>
<li>Sequenced Collections 是 Java 标准库的一部分，从 Java 17 开始引入。</li>
<li>Sequenced Collections 提供了多种集合类型，如 SequencedHashMap、SequencedArrayList 等。</li>
<li>Sequenced Collections 可以与其他 Java 集合类（如 ArrayList、LinkedList 等）一起使用，以满足不同的需求。</li>
</ul>
<h2 id="8- 总结 -1"><a href="#8- 总结 -1" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>Sequenced Collections 是 Java 中的一个新特性，它提供了一种有序的、线程安全的集合实现。它通过使用 Sequenced<br>Locks 机制来保证线程安全性和并发性能。Sequenced Collections 具有高效性能、可扩展性等优点，但也存在额外开销和写操作延迟的缺点。在使用 Sequenced<br>Collections 时，我们可以创建 SequencedHashMap、SequencedArrayList 等集合类型，并使用 put、get、forEach 等方法来操作集合中的数据。</p>
<h1 id="439-Generational-ZGC"><a href="#439-Generational-ZGC" class="headerlink" title="| 439: | Generational ZGC |"></a>| 439: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/439">Generational ZGC</a> |</h1><h2 id="1- 什么是 Generational-ZGC"><a href="#1- 什么是 Generational-ZGC" class="headerlink" title="1. 什么是 Generational ZGC?"></a>1. 什么是 Generational ZGC?</h2><p>Generational ZGC（Z Garbage Collector）是一种用于 Java 虚拟机（JVM）的垃圾回收器。它是 OpenJDK 项目中的一个特性，旨在提供低延迟和高吞吐量的垃圾回收解决方案。</p>
<h2 id="2- 为什么需要 Generational-ZGC"><a href="#2- 为什么需要 Generational-ZGC" class="headerlink" title="2. 为什么需要 Generational ZGC?"></a>2. 为什么需要 Generational ZGC?</h2><p>传统的垃圾回收器在处理大型堆内存时可能会导致长时间的停顿，这对于需要快速响应和低延迟的应用程序来说是不可接受的。Generational<br>ZGC 的目标是减少这些停顿时间，并且能够处理非常大的堆内存。</p>
<h2 id="3-Generational-ZGC 的实现原理"><a href="#3-Generational-ZGC 的实现原理" class="headerlink" title="3. Generational ZGC 的实现原理"></a>3. Generational ZGC 的实现原理</h2><p>Generational ZGC 基于分代垃圾回收的概念，将堆内存划分为多个代。其中包括 Young Generation（年轻代）和 Old<br>Generation（老年代）。具体的实现原理如下：</p>
<h3 id="年轻代（Young-Generation）"><a href="# 年轻代（Young-Generation）" class="headerlink" title="年轻代（Young Generation）"></a>年轻代（Young Generation）</h3><ul>
<li>年轻代使用了 Region 的概念，将整个年轻代划分为多个大小相等的区域。</li>
<li>每个区域都有一个指针指向下一个可用的区域，形成一个链表结构。</li>
<li>当对象被创建时，它们首先被分配到年轻代的某个区域中。</li>
<li>当一个区域被填满时，会触发一次年轻代垃圾回收（Minor GC）。</li>
<li>Minor GC 使用了并行和压缩算法来回收不再使用的对象。</li>
</ul>
<h3 id="老年代（Old-Generation）"><a href="# 老年代（Old-Generation）" class="headerlink" title="老年代（Old Generation）"></a>老年代（Old Generation）</h3><ul>
<li>老年代是存放生命周期较长的对象的区域。</li>
<li>当一个对象在年轻代经历了多次垃圾回收后仍然存活，它将被晋升到老年代。</li>
<li>当老年代空间不足时，会触发一次老年代垃圾回收（Major GC）。</li>
<li>Major GC 使用了并发标记和并行清理算法来回收不再使用的对象。</li>
</ul>
<h3 id="并发处理"><a href="# 并发处理" class="headerlink" title="并发处理"></a>并发处理</h3><p>Generational ZGC 采用了并发处理的方式来减少停顿时间。具体包括：</p>
<ul>
<li>年轻代垃圾回收过程中，应用程序可以继续执行。</li>
<li>在老年代垃圾回收过程中，应用程序也可以继续执行，只有在最后的清理阶段才会产生短暂的停顿。</li>
</ul>
<h2 id="4-Generational-ZGC 的优点"><a href="#4-Generational-ZGC 的优点" class="headerlink" title="4. Generational ZGC 的优点"></a>4. Generational ZGC 的优点</h2><ul>
<li><strong>低延迟</strong>：Generational ZGC 通过并发处理和分代回收的策略，实现了非常低的停顿时间，适合对响应时间要求高的应用场景。</li>
<li><strong>高吞吐量</strong>：Generational ZGC 在尽可能减少停顿时间的同时，也能保持较高的垃圾回收吞吐量。</li>
<li><strong>大堆支持</strong>：Generational ZGC 可以处理非常大的堆内存，适用于需要大内存容量的应用程序。</li>
</ul>
<h2 id="5-Generational-ZGC 的缺点"><a href="#5-Generational-ZGC 的缺点" class="headerlink" title="5. Generational ZGC 的缺点"></a>5. Generational ZGC 的缺点</h2><ul>
<li><strong>性能开销</strong>：由于并发处理和分代回收的策略，Generational ZGC 会带来一定的性能开销。这主要体现在 CPU 和内存的使用上。</li>
<li><strong>配置复杂</strong>：Generational ZGC 有一些与性能相关的配置参数，需要根据具体场景进行调整，对于不熟悉的用户来说可能比较复杂。</li>
</ul>
<h2 id="6-Generational-ZGC 的使用示例"><a href="#6-Generational-ZGC 的使用示例" class="headerlink" title="6. Generational ZGC 的使用示例"></a>6. Generational ZGC 的使用示例 </h2><p> 以下是一个简单的 Java 代码示例，展示了如何启用 Generational ZGC：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+UnlockExperimentalVMOptions -XX:+UseZGC YourApplication</span><br></pre></td></tr></table></figure>

<h2 id="7-Generational-ZGC 的使用注意事项"><a href="#7-Generational-ZGC 的使用注意事项" class="headerlink" title="7. Generational ZGC 的使用注意事项"></a>7. Generational ZGC 的使用注意事项</h2><ul>
<li>Generational ZGC 是 OpenJDK 项目中的新特性，虽然已经相当稳定，但仍然建议在生产环境中进行充分测试。</li>
<li>在使用 Generational ZGC 时，建议监控系统资源使用情况，以便及时调整配置参数或采取其他措施来优化性能。</li>
</ul>
<h2 id="8- 总结 -2"><a href="#8- 总结 -2" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>Generational ZGC 是一种用于 Java 虚拟机的垃圾回收器，旨在提供低延迟和高吞吐量的垃圾回收解决方案。它通过并发处理和分代回收的策略，实现了非常低的停顿时间，并且能够处理非常大的堆内存。然而，使用 Generational<br>ZGC 需要注意性能开销和配置复杂性。</p>
<h1 id="440-Record-Patterns"><a href="#440-Record-Patterns" class="headerlink" title="| 440: | Record Patterns |"></a>| 440: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/440">Record Patterns</a> |</h1><h2 id="1- 什么是 Record-Patterns"><a href="#1- 什么是 Record-Patterns" class="headerlink" title="1. 什么是 Record Patterns?"></a>1. 什么是 Record Patterns?</h2><p>Record Patterns 是 Java 16 中引入的一个新特性，它允许我们在模式匹配中使用记录类型（record<br>types）。记录类型是一种新的类声明形式，用于定义不可变的数据对象。而 Record Patterns 则提供了一种简洁的方式来进行模式匹配，并且可以方便地从记录类型中提取字段值。</p>
<h2 id="2- 为什么需要 Record-Patterns"><a href="#2- 为什么需要 Record-Patterns" class="headerlink" title="2. 为什么需要 Record Patterns?"></a>2. 为什么需要 Record Patterns?</h2><p>在传统的 Java 编程中，当我们需要对某个对象的属性进行判断和提取时，通常需要手动编写大量的代码来完成这些操作。而引入 Record<br>Patterns 可以极大地简化这个过程，使得代码更加清晰、简洁，并且减少了出错的可能性。</p>
<h2 id="3-Record-Patterns- 的实现原理"><a href="#3-Record-Patterns- 的实现原理" class="headerlink" title="3. Record Patterns 的实现原理"></a>3. Record Patterns 的实现原理</h2><p>Record Patterns 的实现原理主要涉及两个方面：记录类型和模式匹配。</p>
<h3 id="记录类型"><a href="# 记录类型" class="headerlink" title="记录类型"></a>记录类型 </h3><p> 记录类型是一种新的类声明形式，通过 <code>record</code> 关键字来定义。它自动提供了以下功能：</p>
<ul>
<li>自动生成私有 final 字段，并根据构造函数参数初始化这些字段。</li>
<li>自动生成 <code>equals()</code>、<code>hashCode()</code> 和 <code>toString()</code> 方法。</li>
<li>提供了一种紧凑的语法来定义字段和构造函数。</li>
</ul>
<h3 id="模式匹配"><a href="# 模式匹配" class="headerlink" title="模式匹配"></a>模式匹配 </h3><p> 模式匹配是指根据给定的模式来匹配某个对象，并执行相应的操作。在 Record Patterns 中，我们可以使用 <code>instanceof</code><br>关键字和模式变量来进行模式匹配。</p>
<p>具体地说，当我们使用 Record Patterns<br>进行模式匹配时，编译器会自动为记录类型生成一个模式匹配方法。这个方法接受一个对象作为参数，并根据给定的模式进行匹配。如果匹配成功，则将字段值绑定到相应的模式变量中，从而可以在后续代码中使用。</p>
<h2 id="4-Record-Patterns- 的优点"><a href="#4-Record-Patterns- 的优点" class="headerlink" title="4. Record Patterns 的优点"></a>4. Record Patterns 的优点</h2><p>Record Patterns 带来了以下几个优点：</p>
<ul>
<li><strong>简洁性</strong>：使用 Record Patterns 可以大大简化对记录类型的模式匹配操作，减少冗余代码。</li>
<li><strong>可读性</strong>：Record Patterns 提供了一种直观、清晰的语法，使得代码更易于理解和维护。</li>
<li><strong>安全性</strong>：由于 Record Patterns 自动生成了 equals() 和 hashCode() 方法，可以避免手动实现这些方法时可能出现的错误。</li>
<li><strong>提高开发效率</strong>：Record Patterns 可以减少重复劳动，提高开发效率。</li>
</ul>
<h2 id="5-Record-Patterns- 的缺点"><a href="#5-Record-Patterns- 的缺点" class="headerlink" title="5. Record Patterns 的缺点"></a>5. Record Patterns 的缺点 </h2><p> 尽管 Record Patterns 带来了很多好处，但也存在一些限制和缺点：</p>
<ul>
<li><strong>不可变性</strong>：记录类型是不可变的，即字段值不能被修改。这意味着如果需要修改某个字段的值，就必须创建一个新的记录对象。</li>
<li><strong>局限性</strong>：Record Patterns 目前只能用于记录类型，不能用于其他类。</li>
<li><strong>兼容性</strong>：由于 Record Patterns 是在 Java 16 中引入的新特性，因此需要使用 Java 16 或更高版本才能使用。</li>
</ul>
<h2 id="6-Record-Patterns- 的使用示例"><a href="#6-Record-Patterns- 的使用示例" class="headerlink" title="6. Record Patterns 的使用示例"></a>6. Record Patterns 的使用示例 </h2><p> 下面是一个简单的示例，展示了如何使用 Record Patterns 进行模式匹配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (person <span class="keyword">instanceof</span> Person p) &#123;</span><br><span class="line">            System.out.println(p.name()); <span class="comment">// 输出 &quot;Alice&quot;</span></span><br><span class="line">            System.out.println(p.age()); <span class="comment">// 输出 25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 <code>Person</code> 的记录类型，并创建了一个 <code>Person</code> 对象。然后，我们使用 Record Patterns<br>进行模式匹配，将字段值绑定到模式变量 <code>p</code> 中，并输出字段值。</p>
<h2 id="7-Record-Patterns- 的使用注意事项"><a href="#7-Record-Patterns- 的使用注意事项" class="headerlink" title="7. Record Patterns 的使用注意事项"></a>7. Record Patterns 的使用注意事项 </h2><p> 在使用 Record Patterns 时，需要注意以下几点：</p>
<ul>
<li>记录类型的字段默认是 final 的，即不能被修改。如果需要修改某个字段的值，就必须创建一个新的记录对象。</li>
<li>记录类型的构造函数参数和字段名称要一致，否则会导致编译错误。</li>
<li>模式匹配方法的命名规则是 <code>match&lt;RecordTypeName&gt;</code>，例如 <code>matchPerson()</code>。</li>
</ul>
<h2 id="8- 总结 -3"><a href="#8- 总结 -3" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>Record Patterns 是 Java 16 引入的一个新特性，它提供了一种简洁、清晰的方式来进行模式匹配，并且可以方便地从记录类型中提取字段值。使用<br>Record Patterns 可以使代码更加简洁、可读，并提高开发效率。然而，由于记录类型是不可变的，因此在修改字段值时需要创建新的对象。同时，Record<br>Patterns 目前只能用于记录类型，不能用于其他类。</p>
<h1 id="441-Pattern-Matching-for-switch"><a href="#441-Pattern-Matching-for-switch" class="headerlink" title="| 441: | Pattern Matching for switch |"></a>| 441: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/441">Pattern Matching for switch</a> |</h1><h2 id="1- 什么是 -Pattern-Matching-for-switch"><a href="#1- 什么是 -Pattern-Matching-for-switch" class="headerlink" title="1. 什么是 Pattern Matching for switch?"></a>1. 什么是 Pattern Matching for switch?</h2><p>Pattern Matching for switch 是 Java 14 中引入的一个新特性，它允许在 switch 语句中使用模式匹配。通过这个特性，我们可以更方便地对变量进行类型判断和提取。</p>
<h2 id="2- 为什么需要 -Pattern-Matching-for-switch"><a href="#2- 为什么需要 -Pattern-Matching-for-switch" class="headerlink" title="2. 为什么需要 Pattern Matching for switch?"></a>2. 为什么需要 Pattern Matching for switch?</h2><p>在之前的 Java 版本中，如果我们想要根据不同的类型执行不同的逻辑，通常需要使用多个 if-else 或者 switch-case<br>来进行判断。这样的代码结构比较冗长，并且容易出错。而 Pattern Matching for switch 的引入，使得我们能够更简洁、清晰地处理这种情况。</p>
<h2 id="3-Pattern-Matching-for-switch- 的实现原理"><a href="#3-Pattern-Matching-for-switch- 的实现原理" class="headerlink" title="3. Pattern Matching for switch 的实现原理"></a>3. Pattern Matching for switch 的实现原理</h2><p>Pattern Matching for switch 的实现原理主要涉及两个方面：模式匹配和类型推断。</p>
<h3 id="模式匹配 -1"><a href="# 模式匹配 -1" class="headerlink" title="模式匹配"></a>模式匹配 </h3><p> 模式匹配是指将某个值与一系列模式进行比较，以确定是否匹配。在 Pattern Matching for switch 中，我们可以使用关键字 <code>case</code><br>后跟上模式来进行匹配。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">case</span> String s -&gt; s.length();</span><br><span class="line">    <span class="keyword">case</span> Integer i -&gt; i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>case String s</code> 和 <code>case Integer i</code> 就是模式，它们分别用于匹配字符串和整数类型的对象。</p>
<h3 id="类型推断"><a href="# 类型推断" class="headerlink" title="类型推断"></a>类型推断 </h3><p> 类型推断是指根据上下文信息，自动推断出某个表达式的类型。在 Pattern Matching for switch 中，我们可以使用 <code>var</code><br>关键字来进行类型推断。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">case</span> String s -&gt; s.length();</span><br><span class="line">    <span class="keyword">case</span> Integer i -&gt; i * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span> -&gt; -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>var</code> 关键字用于推断 <code>result</code> 的类型为 <code>int</code>。</p>
<h2 id="4-Pattern-Matching-for-switch- 的优点"><a href="#4-Pattern-Matching-for-switch- 的优点" class="headerlink" title="4. Pattern Matching for switch 的优点"></a>4. Pattern Matching for switch 的优点</h2><ul>
<li>简化了对变量类型的判断和提取逻辑，使代码更加简洁、清晰。</li>
<li>减少了重复的代码，提高了开发效率。</li>
<li>增强了代码的可读性和可维护性。</li>
</ul>
<h2 id="5-Pattern-Matching-for-switch- 的缺点"><a href="#5-Pattern-Matching-for-switch- 的缺点" class="headerlink" title="5. Pattern Matching for switch 的缺点"></a>5. Pattern Matching for switch 的缺点</h2><ul>
<li>只能用于 switch 语句中，不能直接用于 if-else 结构。</li>
<li>目前只支持基本数据类型和引用类型的模式匹配，不支持其他特殊类型（如枚举、数组等）的模式匹配。</li>
</ul>
<h2 id="6-Pattern-Matching-for-switch- 的使用示例"><a href="#6-Pattern-Matching-for-switch- 的使用示例" class="headerlink" title="6. Pattern Matching for switch 的使用示例"></a>6. Pattern Matching for switch 的使用示例 </h2><p> 下面是一个使用 Pattern Matching for switch 的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (obj) &#123;</span><br><span class="line">        <span class="keyword">case</span> String s -&gt; System.out.println(<span class="string">&quot;String: &quot;</span> + s);</span><br><span class="line">        <span class="keyword">case</span> Integer i -&gt; System.out.println(<span class="string">&quot;Integer: &quot;</span> + i);</span><br><span class="line">        <span class="keyword">case</span> Double d -&gt; System.out.println(<span class="string">&quot;Double: &quot;</span> + d);</span><br><span class="line">        <span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;Unknown type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，根据传入的对象类型不同，会执行相应的逻辑。</p>
<h2 id="7-Pattern-Matching-for-switch- 的使用注意事项"><a href="#7-Pattern-Matching-for-switch- 的使用注意事项" class="headerlink" title="7. Pattern Matching for switch 的使用注意事项"></a>7. Pattern Matching for switch 的使用注意事项</h2><ul>
<li>模式匹配是按照 <code>case</code> 的顺序进行匹配的，因此需要将更具体的模式放在前面。</li>
<li>如果没有匹配到任何模式，则会执行 <code>default</code> 分支的逻辑。</li>
<li>在一个 <code>switch</code> 块内部，每个模式只能出现一次，否则会编译报错。</li>
</ul>
<h2 id="8- 总结 -4"><a href="#8- 总结 -4" class="headerlink" title="8. 总结"></a>8. 总结 </h2><p>Pattern Matching for switch 是 Java 14 中引入的一个新特性，它允许在 switch<br> 语句中使用模式匹配。通过这个特性，我们可以更方便地对变量进行类型判断和提取。它简化了对变量类型的判断和提取逻辑，使代码更加简洁、清晰，并且增强了代码的可读性和可维护性。但需要注意的是，目前只支持基本数据类型和引用类型的模式匹配，不支持其他特殊类型的模式匹配。</p>
<h1 id="442-Foreign-Function-Memory-API-Third-Preview"><a href="#442-Foreign-Function-Memory-API-Third-Preview" class="headerlink" title="| 442: | Foreign Function &amp; Memory API (Third Preview) |"></a>| 442: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/442">Foreign Function &amp; Memory API (Third Preview)</a> |</h1><h2 id="1- 什么是 Foreign-Function-Memory-API-Third-Preview"><a href="#1- 什么是 Foreign-Function-Memory-API-Third-Preview" class="headerlink" title="1. 什么是 Foreign Function &amp; Memory API (Third Preview)?"></a>1. 什么是 Foreign Function &amp; Memory API (Third Preview)?</h2><p>Foreign Function &amp; Memory API 是 Java 平台的一个功能，它允许开发者直接与本地代码进行交互，并且可以在 Java 中操作本地内存。这个功能最初在 <br>JDK 14 的时候以 JEP 383 的形式引入了第一次预览版，然后在 JDK 15 中进一步改进并发布了第二次预览版（JEP 393），现在在 JDK 21<br> 中发布了第三次预览版（JEP 442）。</p>
<h2 id="2- 为什么需要 Foreign-Function-Memory-API"><a href="#2- 为什么需要 Foreign-Function-Memory-API" class="headerlink" title="2. 为什么需要 Foreign Function &amp; Memory API?"></a>2. 为什么需要 Foreign Function &amp; Memory API?</h2><p>Foreign Function &amp; Memory API 的出现主要是为了解决以下几个问题：</p>
<ul>
<li><strong>与本地代码的无缝集成</strong>：有些场景下，我们可能需要调用本地库或者系统级别的函数，例如使用硬件加速、调用底层操作系统的特定功能等。而<br>Foreign Function &amp; Memory API 可以使得 Java 程序能够直接调用本地函数，从而实现与本地代码的无缝集成。</li>
<li><strong>提高性能</strong>：通过直接操作本地内存，可以避免数据拷贝和类型转换带来的性能损耗，从而提高程序的执行效率。</li>
<li><strong>扩展现有 Java 库的功能</strong>：Foreign Function &amp; Memory API 提供了一种机制，可以将本地库中的函数包装成 Java 接口，从而方便地扩展现有的<br>Java 库的功能。</li>
</ul>
<h2 id="3-Foreign-Function-Memory-API- 的实现原理"><a href="#3-Foreign-Function-Memory-API- 的实现原理" class="headerlink" title="3. Foreign Function &amp; Memory API 的实现原理"></a>3. Foreign Function &amp; Memory API 的实现原理</h2><p>Foreign Function &amp; Memory API 的实现主要依赖于以下几个关键技术：</p>
<ul>
<li><strong>JNI（Java Native Interface）</strong>：JNI 是 Java 平台提供的一种机制，用于在 Java 程序中调用本地代码。Foreign Function &amp; Memory<br>API 利用 JNI 提供的能力，使得 Java 程序可以直接调用本地函数。</li>
<li><strong>内存管理</strong>：Foreign Function &amp; Memory API 允许开发者直接操作本地内存，包括分配、释放和读写等操作。这需要对内存进行有效的管理，以确保安全性和可靠性。</li>
<li><strong>类型映射 </strong>：由于 Java 和本地代码使用不同的数据类型表示数据，因此需要进行类型映射。Foreign Function &amp; Memory API<br> 提供了一套规则和工具，用于将 Java 类型与本地类型进行转换。</li>
</ul>
<h2 id="4-Foreign-Function-Memory-API- 的优点"><a href="#4-Foreign-Function-Memory-API- 的优点" class="headerlink" title="4. Foreign Function &amp; Memory API 的优点"></a>4. Foreign Function &amp; Memory API 的优点</h2><ul>
<li><strong>无缝集成</strong>：Foreign Function &amp; Memory API 可以使得 Java 程序能够直接调用本地函数，从而实现与本地代码的无缝集成。</li>
<li><strong>高性能</strong>：通过直接操作本地内存，避免了数据拷贝和类型转换带来的性能损耗，从而提高程序的执行效率。</li>
<li><strong>灵活性</strong>：Foreign Function &amp; Memory API 提供了丰富的功能和灵活的接口，可以满足不同场景下的需求。</li>
</ul>
<h2 id="5-Foreign-Function-Memory-API- 的缺点"><a href="#5-Foreign-Function-Memory-API- 的缺点" class="headerlink" title="5. Foreign Function &amp; Memory API 的缺点"></a>5. Foreign Function &amp; Memory API 的缺点</h2><ul>
<li><strong>安全性风险</strong>：直接操作本地内存可能会带来一些安全风险，例如内存泄漏、访问非法内存等。因此，在使用 Foreign Function &amp;<br>Memory API 时需要谨慎处理，并遵循相关的安全规范。</li>
<li><strong>复杂性</strong>：Foreign Function &amp; Memory API 涉及到与本地代码的交互和内存管理等复杂的问题，对开发者的要求较高，需要具备一定的底层编程知识和经验。</li>
</ul>
<h2 id="6-Foreign-Function-Memory-API- 的使用示例"><a href="#6-Foreign-Function-Memory-API- 的使用示例" class="headerlink" title="6. Foreign Function &amp; Memory API 的使用示例"></a>6. Foreign Function &amp; Memory API 的使用示例 </h2><p> 以下是一个简单的示例，展示了如何使用 Foreign Function &amp; Memory API 调用本地函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jdk.incubator.foreign.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NativeFunctionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">MemorySegment</span> <span class="variable">segment</span> <span class="operator">=</span> MemorySegment.allocateNative(<span class="number">4</span>)) &#123;</span><br><span class="line">            <span class="type">CLinker</span> <span class="variable">linker</span> <span class="operator">=</span> CLinker.getInstance();</span><br><span class="line">            <span class="type">FunctionDescriptor</span> <span class="variable">descriptor</span> <span class="operator">=</span> FunctionDescriptor.of(CLinker.C_INT, CLinker.C_POINTER);</span><br><span class="line">            <span class="type">LibraryLookup</span> <span class="variable">lookup</span> <span class="operator">=</span> LibraryLookup.ofDefault();</span><br><span class="line">            <span class="type">Symbol</span> <span class="variable">symbol</span> <span class="operator">=</span> lookup.lookup(<span class="string">&quot;printf&quot;</span>);</span><br><span class="line">            <span class="type">FunctionHandle</span> <span class="variable">handle</span> <span class="operator">=</span> linker.downcallHandle(symbol, descriptor);</span><br><span class="line">            </span><br><span class="line">            <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">            MemoryAccess.setCString(segment.baseAddress(), message);</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> (<span class="type">int</span>) handle.invokeExact(segment.baseAddress());</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，我们使用 Foreign Function &amp; Memory API 调用了本地的 printf 函数，并将结果打印出来。</p>
<h2 id="7-Foreign-Function-Memory-API- 的使用注意事项"><a href="#7-Foreign-Function-Memory-API- 的使用注意事项" class="headerlink" title="7. Foreign Function &amp; Memory API 的使用注意事项"></a>7. Foreign Function &amp; Memory API 的使用注意事项</h2><ul>
<li>在使用 Foreign Function &amp; Memory API 时，需要确保本地函数和库已经正确安装并可用。</li>
<li>对于直接操作本地内存的情况，需要特别注意内存管理和安全性问题，避免出现内存泄漏、访问非法内存等问题。</li>
<li>使用 Foreign Function &amp; Memory API 需要谨慎处理异常，以确保程序的稳定性和可靠性。</li>
</ul>
<h2 id="8- 总结 -5"><a href="#8- 总结 -5" class="headerlink" title="8. 总结"></a>8. 总结 </h2><p>Foreign Function &amp; Memory API 是 Java 平台提供的一种机制，可以使得 Java 程序能够直接调用本地函数，并且可以在 Java<br> 中操作本地内存。它通过 JNI 技术实现与本地代码的无缝集成，并提供了高性能和灵活性。然而，在使用 Foreign Function &amp; Memory API<br>时需要注意安全性和复杂性等问题，以确保程序的稳定性和可靠性。</p>
<h1 id="443-Unnamed-Patterns-and-Variables-Preview"><a href="#443-Unnamed-Patterns-and-Variables-Preview" class="headerlink" title="| 443: | Unnamed Patterns and Variables (Preview) |"></a>| 443: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/443">Unnamed Patterns and Variables (Preview)</a> |</h1><h2 id="1- 什么是 Unnamed-Patterns-and-Variables-Preview"><a href="#1- 什么是 Unnamed-Patterns-and-Variables-Preview" class="headerlink" title="1. 什么是 Unnamed Patterns and Variables (Preview)?"></a>1. 什么是 Unnamed Patterns and Variables (Preview)?</h2><p>Unnamed Patterns and Variables 是 Java 编程语言的一个新特性，它在 JDK 14 中引入，并在 JDK 15<br>中作为预览功能继续存在。该特性允许我们使用匿名模式和变量来简化代码并提高可读性。</p>
<h2 id="2- 为什么需要 Unnamed-Patterns-and-Variables"><a href="#2- 为什么需要 Unnamed-Patterns-and-Variables" class="headerlink" title="2. 为什么需要 Unnamed Patterns and Variables?"></a>2. 为什么需要 Unnamed Patterns and Variables?</h2><p>在传统的 Java 代码中，当我们需要对某个对象进行模式匹配时，通常需要创建一个临时变量来存储匹配结果。这样会导致代码冗长、可读性差，并且增加了不必要的命名负担。</p>
<p>而 Unnamed Patterns and Variables 的出现正是为了解决这个问题。通过使用匿名模式和变量，我们可以直接在模式匹配表达式中使用，避免了创建临时变量的麻烦，使得代码更加简洁和易于理解。</p>
<h2 id="3-Unnamed-Patterns-and-Variables- 的实现原理"><a href="#3-Unnamed-Patterns-and-Variables- 的实现原理" class="headerlink" title="3. Unnamed Patterns and Variables 的实现原理"></a>3. Unnamed Patterns and Variables 的实现原理</h2><p>Unnamed Patterns and Variables 的实现原理主要涉及两个方面：匿名模式和匿名变量。</p>
<h3 id="匿名模式"><a href="# 匿名模式" class="headerlink" title="匿名模式"></a>匿名模式 </h3><p> 匿名模式是一种特殊的模式，用于表示我们只关心某个值是否满足某个条件，而不关心具体的值是什么。在匿名模式中，我们使用下划线 <code>_</code><br>来代替具体的变量名。</p>
<p>例如，我们可以使用匿名模式来判断一个对象是否为 null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String _) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;obj is a non-null string&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匿名变量"><a href="# 匿名变量" class="headerlink" title="匿名变量"></a>匿名变量 </h3><p> 匿名变量是一种特殊的变量，用于表示我们不需要使用该变量的值。在匿名变量中，我们同样使用下划线 <code>_</code> 来代替具体的变量名。</p>
<p>例如，在 switch 语句中，我们可以使用匿名变量来忽略某些分支的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (dayOfWeek) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, TUESDAY, WEDNESDAY, THURSDAY -&gt; System.out.println(<span class="string">&quot;Weekday&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> FRIDAY -&gt; System.out.println(<span class="string">&quot;Friday&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> SATURDAY, SUNDAY -&gt; System.out.println(<span class="string">&quot;Weekend&quot;</span>);</span><br><span class="line">    <span class="keyword">default</span> -&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Invalid day of week: &quot;</span> + dayOfWeek);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Unnamed-Patterns-and-Variables- 的优点"><a href="#4-Unnamed-Patterns-and-Variables- 的优点" class="headerlink" title="4. Unnamed Patterns and Variables 的优点"></a>4. Unnamed Patterns and Variables 的优点</h2><ul>
<li><strong>简化代码</strong>：通过使用匿名模式和变量，可以减少临时变量的创建，使得代码更加简洁。</li>
<li><strong>提高可读性</strong>：匿名模式和变量能够直接表达我们关心的条件，避免了命名的繁琐，使得代码更易于理解。</li>
</ul>
<h2 id="5-Unnamed-Patterns-and-Variables- 的缺点"><a href="#5-Unnamed-Patterns-and-Variables- 的缺点" class="headerlink" title="5. Unnamed Patterns and Variables 的缺点"></a>5. Unnamed Patterns and Variables 的缺点 </h2><p> 由于 Unnamed Patterns and Variables 目前仍处于预览阶段，因此存在以下一些限制和潜在问题：</p>
<ul>
<li><strong>兼容性问题</strong>：由于该特性是在 JDK 14 中引入的，并且仍处于预览阶段，因此可能存在与旧版本 Java 不兼容的问题。</li>
<li><strong>语法限制</strong>：匿名模式和变量只能用于某些特定的上下文中，不能在所有地方使用。例如，在 lambda 表达式、方法引用等场景中暂时还无法使用。</li>
</ul>
<h2 id="6-Unnamed-Patterns-and-Variables- 的使用示例"><a href="#6-Unnamed-Patterns-and-Variables- 的使用示例" class="headerlink" title="6. Unnamed Patterns and Variables 的使用示例"></a>6. Unnamed Patterns and Variables 的使用示例 </h2><p> 以下是一个使用匿名模式和变量的示例代码，用于判断一个对象是否为非空字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String _) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;obj is a non-null string&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Unnamed-Patterns-and-Variables- 的使用注意事项"><a href="#7-Unnamed-Patterns-and-Variables- 的使用注意事项" class="headerlink" title="7. Unnamed Patterns and Variables 的使用注意事项"></a>7. Unnamed Patterns and Variables 的使用注意事项 </h2><p> 在使用 Unnamed Patterns and Variables 时，需要注意以下几点：</p>
<ul>
<li>匿名模式和变量只能用于表示我们不关心具体值的情况，如果需要获取具体的值，则应该使用普通的命名模式和变量。</li>
<li>在一些特殊的上下文中，如 lambda 表达式、方法引用等，目前还无法使用匿名模式和变量。</li>
</ul>
<h2 id="8- 总结 -6"><a href="#8- 总结 -6" class="headerlink" title="8. 总结"></a>8. 总结 </h2><p>Unnamed Patterns and Variables 是 Java<br> 编程语言的一个新特性，它通过引入匿名模式和变量来简化代码并提高可读性。虽然该特性目前仍处于预览阶段，并存在一些限制和潜在问题，但它为我们编写更简洁、易读的代码提供了一种新的方式。</p>
<h1 id="444-Virtual-Threads"><a href="#444-Virtual-Threads" class="headerlink" title="| 444: | Virtual Threads |"></a>| 444: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/444">Virtual Threads</a> |</h1><h2 id="1- 什么是 Virtual-Threads"><a href="#1- 什么是 Virtual-Threads" class="headerlink" title="1. 什么是 Virtual Threads?"></a>1. 什么是 Virtual Threads?</h2><p>Virtual Threads（虚拟线程）是 Java 平台的一项新功能，它旨在改进 Java 中的并发编程模型。传统上，Java 使用基于操作系统线程的并发模型，每个线程都需要分配一个操作系统线程来执行。而 Virtual<br>Threads 则提供了一种更高效、更轻量级的线程模型。</p>
<h2 id="2- 为什么需要 Virtual-Threads"><a href="#2- 为什么需要 Virtual-Threads" class="headerlink" title="2. 为什么需要 Virtual Threads?"></a>2. 为什么需要 Virtual Threads?</h2><p>在传统的基于操作系统线程的并发模型中，创建和销毁线程以及在线程之间切换的开销很大。这限制了 Java 应用程序在处理大规模并发时的性能和扩展性。此外，由于操作系统线程的数量有限，当应用程序需要创建大量线程时，可能会导致资源耗尽或者性能下降。</p>
<p>Virtual<br>Threads 的出现解决了这些问题。它通过引入一种轻量级的线程模型，可以在 Java 应用程序中创建数百万甚至数十亿个线程，而不会受到操作系统线程数量的限制。这使得 Java 应用程序能够更好地适应大规模并发场景，并提供更高的性能和可伸缩性。</p>
<h2 id="3-Virtual-Threads 的实现原理"><a href="#3-Virtual-Threads 的实现原理" class="headerlink" title="3. Virtual Threads 的实现原理"></a>3. Virtual Threads 的实现原理</h2><p>Virtual Threads 的实现依赖于 Java 虚拟机（JVM）的协作调度器和 Fork&#x2F;Join 框架。它通过将多个 Virtual<br>Threads 映射到少量的操作系统线程上来实现高效的并发执行。</p>
<p>具体而言，当一个 Java 应用程序创建一个 Virtual<br>Thread 时，JVM 会为其分配一个虚拟线程（也称为轻量级线程）。这些虚拟线程由协作调度器管理，并在需要时与操作系统线程进行绑定。协作调度器负责决定哪个虚拟线程可以运行以及何时切换虚拟线程。</p>
<p>Fork&#x2F;Join 框架是 Virtual Threads 的另一个关键组件。它提供了一种任务并行编程模型，允许开发人员将任务分解成更小的子任务，并使用工作窃取算法来实现负载均衡。Virtual<br>Threads 利用 Fork&#x2F;Join 框架的能力，在不同的虚拟线程之间自动地、透明地进行任务划分和调度。</p>
<h2 id="4-Virtual-Threads 的优点"><a href="#4-Virtual-Threads 的优点" class="headerlink" title="4. Virtual Threads 的优点"></a>4. Virtual Threads 的优点</h2><ul>
<li><strong>更高的性能</strong>：Virtual Threads 减少了线程创建和销毁的开销，同时避免了操作系统线程数量的限制，从而提供更高的性能。</li>
<li><strong>更好的可伸缩性</strong>：由于 Virtual Threads 可以创建数百万甚至数十亿个线程，因此 Java 应用程序可以更好地适应大规模并发场景，并具有更好的可伸缩性。</li>
<li><strong>更低的资源消耗</strong>：相比于操作系统线程，Virtual Threads 是轻量级的，占用更少的内存和 CPU 资源。</li>
</ul>
<h2 id="5-Virtual-Threads 的缺点"><a href="#5-Virtual-Threads 的缺点" class="headerlink" title="5. Virtual Threads 的缺点"></a>5. Virtual Threads 的缺点 </h2><p> 虽然 Virtual Threads 带来了许多优势，但也存在一些潜在的缺点：</p>
<ul>
<li><strong>学习成本较高</strong>：使用 Virtual Threads 需要对并发编程模型有一定的理解，并且需要适应新的 API 和开发范式。</li>
<li><strong>可能引入新的问题</strong>：由于 Virtual Threads 是一个相对较新的功能，可能会存在一些未知的问题或者不稳定性。</li>
</ul>
<h2 id="6-Virtual-Threads 的使用示例"><a href="#6-Virtual-Threads 的使用示例" class="headerlink" title="6. Virtual Threads 的使用示例"></a>6. Virtual Threads 的使用示例 </h2><p> 下面是一个简单的使用 Virtual Threads 的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualThreadsExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> (ThreadPoolExecutor) Executors.newVirtualThreadExecutor();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running on virtual thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，我们使用 <code>Executors.newVirtualThreadExecutor()</code> 方法创建了一个 <code>ThreadPoolExecutor</code> 实例，该实例可以执行 Virtual<br>Threads。然后，我们通过调用 <code>execute()</code> 方法提交了一系列任务，每个任务都会打印当前运行的虚拟线程的名称。</p>
<h2 id="7-Virtual-Threads 的使用注意事项"><a href="#7-Virtual-Threads 的使用注意事项" class="headerlink" title="7. Virtual Threads 的使用注意事项"></a>7. Virtual Threads 的使用注意事项 </h2><p> 在使用 Virtual Threads 时，需要注意以下几点：</p>
<ul>
<li>虽然 Virtual Threads 可以创建大量线程，但过多的线程仍可能导致性能下降或资源耗尽。因此，在设计应用程序时，仍需合理控制并发度。</li>
<li>使用 Virtual Threads 时，需要遵循良好的并发编程实践，如避免共享可变状态、使用适当的同步机制等，以确保线程安全性和正确性。</li>
<li>在迁移现有代码到使用 Virtual Threads 时，需要进行一定的重构和调整，以适应新的 API 和开发范式。</li>
</ul>
<h2 id="8- 总结 -7"><a href="#8- 总结 -7" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>Virtual Threads 是 Java 平台的一项新功能，旨在改进 Java 中的并发编程模型。它通过引入轻量级的虚拟线程，并利用协作调度器和 Fork&#x2F;Join 框架来提供高效的并发执行。Virtual<br>Threads 具有更高的性能、更好的可伸缩性和较低的资源消耗，但也需要学习成本较高，并且可能存在一些潜在的问题。在使用 Virtual<br>Threads 时，需要注意合理控制并发度、遵循并发编程实践，并进行必要的重构和调整。</p>
<h1 id="445-Unnamed-Classes-and-Instance-Main-Methods-Preview"><a href="#445-Unnamed-Classes-and-Instance-Main-Methods-Preview" class="headerlink" title="| 445: | Unnamed Classes and Instance Main Methods (Preview) |"></a>| 445: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/445">Unnamed Classes and Instance Main Methods (Preview)</a> |</h1><h2 id="1- 什么是 Unnamed-Classes-and-Instance-Main-Methods-Preview"><a href="#1- 什么是 Unnamed-Classes-and-Instance-Main-Methods-Preview" class="headerlink" title="1. 什么是 Unnamed Classes and Instance Main Methods (Preview)?"></a>1. 什么是 Unnamed Classes and Instance Main Methods (Preview)?</h2><p>“Unnamed Classes and Instance Main Methods” 是一个 Java 编程语言的新特性，它在 JDK 14 中引入，并在 JDK 15<br>中成为预览功能。该特性允许我们在类中定义匿名类和实例主方法。</p>
<p>在传统的 Java 编程中，我们只能在顶级类或静态内部类中定义 main 方法作为程序的入口点。而使用 “Unnamed Classes and Instance<br>Main Methods” 特性后，我们可以在任何类的实例中定义 main 方法，从而使得程序的入口点更加灵活。</p>
<h2 id="2- 为什么需要 Unnamed-Classes-and-Instance-Main-Methods"><a href="#2- 为什么需要 Unnamed-Classes-and-Instance-Main-Methods" class="headerlink" title="2. 为什么需要 Unnamed Classes and Instance Main Methods?"></a>2. 为什么需要 Unnamed Classes and Instance Main Methods?</h2><p>传统的 Java 程序必须将 main<br>方法定义在顶级类或静态内部类中，这限制了程序的结构和组织方式。有时候，我们可能希望将多个相关的逻辑封装在同一个类的实例中，以提高代码的可读性和可维护性。而 “<br>Unnamed Classes and Instance Main Methods” 特性正是为了满足这种需求而引入的。</p>
<p>通过在类的实例中定义 main 方法，我们可以更好地组织和管理程序的逻辑，减少顶级类和静态内部类的数量，使代码更加清晰和易于理解。</p>
<h2 id="3-Unnamed-Classes-and-Instance-Main-Methods- 的实现原理"><a href="#3-Unnamed-Classes-and-Instance-Main-Methods- 的实现原理" class="headerlink" title="3. Unnamed Classes and Instance Main Methods 的实现原理"></a>3. Unnamed Classes and Instance Main Methods 的实现原理</h2><p>“Unnamed Classes and Instance Main Methods” 特性的实现原理涉及到两个方面：匿名类和实例主方法。</p>
<h3 id="3-1- 匿名类"><a href="#3-1- 匿名类" class="headerlink" title="3.1 匿名类"></a>3.1 匿名类 </h3><p> 在 Java 中，我们可以使用匿名类来创建一个没有显式名称的类。匿名类通常用于创建临时的、只需要一次使用的类对象。它们可以继承自某个类或实现某个接口，并重写其中的方法。</p>
<p>匿名类的语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 匿名类的成员变量和方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2- 实例主方法"><a href="#3-2- 实例主方法" class="headerlink" title="3.2 实例主方法"></a>3.2 实例主方法 </h3><p> 传统的 Java 程序入口点是通过静态 main 方法来定义的，而 “Unnamed Classes and Instance Main Methods” 特性允许我们在类的实例中定义<br>main 方法。</p>
<p>实例主方法的语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 主方法的代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Unnamed-Classes-and-Instance-Main-Methods- 的优点"><a href="#4-Unnamed-Classes-and-Instance-Main-Methods- 的优点" class="headerlink" title="4. Unnamed Classes and Instance Main Methods 的优点"></a>4. Unnamed Classes and Instance Main Methods 的优点</h2><ul>
<li><strong>灵活性</strong>：通过在类的实例中定义 main 方法，程序的入口点更加灵活，可以根据需求将多个相关的逻辑封装在同一个类的实例中。</li>
<li><strong>可读性</strong>：将相关的逻辑组织在同一个类的实例中，使得代码更加清晰和易于理解。</li>
<li><strong>可维护性</strong>：减少顶级类和静态内部类的数量，简化代码结构，提高代码的可维护性。</li>
</ul>
<h2 id="5-Unnamed-Classes-and-Instance-Main-Methods- 的缺点"><a href="#5-Unnamed-Classes-and-Instance-Main-Methods- 的缺点" class="headerlink" title="5. Unnamed Classes and Instance Main Methods 的缺点"></a>5. Unnamed Classes and Instance Main Methods 的缺点</h2><ul>
<li><strong>语法复杂</strong>：匿名类和实例主方法的语法相对传统的 main 方法更加复杂，需要额外的学习成本。</li>
<li><strong>可读性降低</strong>：如果滥用该特性，将多个逻辑封装在同一个类的实例中可能会导致代码可读性下降。</li>
</ul>
<h2 id="6-Unnamed-Classes-and-Instance-Main-Methods- 的使用示例"><a href="#6-Unnamed-Classes-and-Instance-Main-Methods- 的使用示例" class="headerlink" title="6. Unnamed Classes and Instance Main Methods 的使用示例"></a>6. Unnamed Classes and Instance Main Methods 的使用示例 </h2><p> 下面是一个使用 “Unnamed Classes and Instance Main Methods” 特性的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Example</span>().main(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 <code>Example</code> 的类，并在其中创建了一个实例。通过调用实例的 <code>main</code><br>方法，程序的入口点被指定为该实例的 <code>main</code> 方法。</p>
<h2 id="7-Unnamed-Classes-and-Instance-Main-Methods- 的使用注意事项"><a href="#7-Unnamed-Classes-and-Instance-Main-Methods- 的使用注意事项" class="headerlink" title="7. Unnamed Classes and Instance Main Methods 的使用注意事项"></a>7. Unnamed Classes and Instance Main Methods 的使用注意事项</h2><ul>
<li>在使用 “Unnamed Classes and Instance Main Methods” 特性时，需要确保每个类的实例只有一个 main 方法，否则编译器将无法确定程序的入口点。</li>
<li>匿名类和实例主方法的语法较为复杂，需要仔细理解并遵循正确的语法规则。</li>
<li>虽然 “Unnamed Classes and Instance Main Methods” 特性在 JDK 15 中成为预览功能，但仍然存在一些潜在的问题和限制。在使用时需要注意这些问题，并及时反馈给开发团队。</li>
</ul>
<h2 id="8- 总结 -8"><a href="#8- 总结 -8" class="headerlink" title="8. 总结"></a>8. 总结 </h2><p>“Unnamed Classes and Instance Main Methods” 是 Java<br> 编程语言的一个新特性，它允许我们在类的实例中定义匿名类和实例主方法。通过该特性，我们可以更灵活地组织程序的逻辑，提高代码的可读性和可维护性。然而，使用该特性需要注意语法复杂性和可读性降低的问题，并遵循正确的使用方式。</p>
<h1 id="446-Scoped-Values-Preview"><a href="#446-Scoped-Values-Preview" class="headerlink" title="| 446: | Scoped Values (Preview) |"></a>| 446: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/446">Scoped Values (Preview)</a> |</h1><h2 id="1- 什么是 Scoped-Values-Preview"><a href="#1- 什么是 Scoped-Values-Preview" class="headerlink" title="1. 什么是 Scoped Values (Preview)?"></a>1. 什么是 Scoped Values (Preview)?</h2><p>Scoped Values (Preview) 是 Java 平台的一个新特性，它在 JDK 17 中引入。该特性旨在提供一种机制，用于在代码块级别上设置和使用临时变量。</p>
<h2 id="2- 为什么需要 Scoped-Values-Preview"><a href="#2- 为什么需要 Scoped-Values-Preview" class="headerlink" title="2. 为什么需要 Scoped Values (Preview)?"></a>2. 为什么需要 Scoped Values (Preview)?</h2><p>在传统的 Java 编程中，我们通常会将变量声明在方法或类的作用域内，并且这些变量的生命周期与其所在的作用域相同。然而，在某些情况下，我们可能希望在更小的范围内定义临时变量，以便更好地控制其可见性和生命周期。</p>
<p>Scoped Values (Preview) 提供了一种简洁、安全的方式来定义和使用临时变量，使得代码更加清晰易读，并且可以减少不必要的命名冲突和资源泄漏问题。</p>
<h2 id="3-Scoped-Values-Preview- 的实现原理"><a href="#3-Scoped-Values-Preview- 的实现原理" class="headerlink" title="3. Scoped Values (Preview) 的实现原理?"></a>3. Scoped Values (Preview) 的实现原理?</h2><p>Scoped Values (Preview) 的实现基于 Java 语言规范中的局部变量类型推断（Local Variable Type Inference）机制。通过使用 var<br>关键字，我们可以在代码块内部声明临时变量，并根据初始化表达式的类型进行类型推断。</p>
<p>例如，以下示例展示了如何使用 Scoped Values (Preview) 声明和使用临时变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 Scoped Values (Preview) 声明临时变量</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在代码块内部使用临时变量</span></span><br><span class="line">    <span class="keyword">if</span> (message.length() &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 Scoped Values (Preview) 声明了一个名为 message 的临时变量，并将其初始化为字符串 “Hello, World!”<br>。然后，在 if 语句的代码块内部，我们可以直接使用该临时变量。</p>
<h2 id="4-Scoped-Values-Preview- 的优点"><a href="#4-Scoped-Values-Preview- 的优点" class="headerlink" title="4. Scoped Values (Preview) 的优点"></a>4. Scoped Values (Preview) 的优点</h2><ul>
<li><strong>简洁性</strong>：Scoped Values (Preview) 提供了一种更简洁的方式来声明和使用临时变量，减少了冗余的代码。</li>
<li><strong>可读性</strong>：通过在代码块级别上定义临时变量，使得代码更加清晰易读，提高了代码的可维护性。</li>
<li><strong>类型安全</strong>：Scoped Values (Preview) 基于 Java 语言规范中的局部变量类型推断机制，确保了变量的类型安全性。</li>
</ul>
<h2 id="5-Scoped-Values-Preview- 的缺点"><a href="#5-Scoped-Values-Preview- 的缺点" class="headerlink" title="5. Scoped Values (Preview) 的缺点"></a>5. Scoped Values (Preview) 的缺点 </h2><p> 尽管 Scoped Values (Preview) 提供了许多优点，但也存在一些潜在的缺点：</p>
<ul>
<li><strong>兼容性问题</strong>：由于 Scoped Values (Preview) 是 JDK 17 中引入的新特性，因此在较旧版本的 Java 中无法使用。</li>
<li><strong>学习成本</strong>：对于不熟悉局部变量类型推断机制的开发人员来说，可能需要一些时间来适应 Scoped Values (Preview) 的使用方式。</li>
</ul>
<h2 id="6-Scoped-Values-Preview- 的使用示例"><a href="#6-Scoped-Values-Preview- 的使用示例" class="headerlink" title="6. Scoped Values (Preview) 的使用示例"></a>6. Scoped Values (Preview) 的使用示例 </h2><p> 以下是一个使用 Scoped Values (Preview) 的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">var</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用 Scoped Values (Preview) 声明了一个名为 message 的临时变量，并将其初始化为字符串 “Hello, World!”<br>。然后，我们通过调用 System.out.println 方法打印该临时变量的值。</p>
<h2 id="7-Scoped-Values-Preview- 的使用注意事项"><a href="#7-Scoped-Values-Preview- 的使用注意事项" class="headerlink" title="7. Scoped Values (Preview) 的使用注意事项"></a>7. Scoped Values (Preview) 的使用注意事项 </h2><p> 在使用 Scoped Values (Preview) 时，需要注意以下几点：</p>
<ul>
<li><strong>作用域限制</strong>：Scoped Values (Preview) 声明的临时变量仅在当前代码块内部可见，超出该代码块范围后将无法访问。</li>
<li><strong>类型推断</strong>：由于 Scoped Values (Preview) 是基于局部变量类型推断机制实现的，因此必须确保初始化表达式具有明确的类型信息，以便进行正确的类型推断。</li>
<li><strong>命名冲突</strong>：当在同一代码块内使用多个 Scoped Values (Preview) 声明临时变量时，需要避免命名冲突，以免引起混淆和错误。</li>
</ul>
<h2 id="8- 总结 -9"><a href="#8- 总结 -9" class="headerlink" title="8. 总结"></a>8. 总结 </h2><p>Scoped Values (Preview) 是 Java 平台的一个新特性，它提供了一种在代码块级别上设置和使用临时变量的机制。通过使用 var<br> 关键字，我们可以在代码块内部声明临时变量，并根据初始化表达式的类型进行类型推断。Scoped Values (Preview)<br>的优点包括简洁性、可读性和类型安全性，但也存在兼容性问题和学习成本。在使用 Scoped Values (Preview)<br>时，需要注意作用域限制、类型推断和命名冲突等注意事项。</p>
<h1 id="448-Vector-API-Sixth-Incubator"><a href="#448-Vector-API-Sixth-Incubator" class="headerlink" title="| 448: | Vector API (Sixth Incubator) |"></a>| 448: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/448">Vector API (Sixth Incubator)</a> |</h1><h2 id="1- 什么是 Vector-API-Sixth-Incubator"><a href="#1- 什么是 Vector-API-Sixth-Incubator" class="headerlink" title="1. 什么是 Vector API (Sixth Incubator)?"></a>1. 什么是 Vector API (Sixth Incubator)?</h2><p>Vector API (Sixth Incubator) 是 Java 平台的一个项目，旨在提供一种简单且高效的方式来执行向量化计算。它引入了新的类和接口，以支持使用<br>SIMD（Single Instruction, Multiple Data）指令集进行并行计算。</p>
<h2 id="2- 为什么需要 Vector-API-Sixth-Incubator"><a href="#2- 为什么需要 Vector-API-Sixth-Incubator" class="headerlink" title="2. 为什么需要 Vector API (Sixth Incubator)?"></a>2. 为什么需要 Vector API (Sixth Incubator)?</h2><p>在许多应用程序中，存在大量的数据并行计算任务，例如图像处理、科学计算和机器学习等领域。传统的 Java<br>编程模型无法充分利用现代硬件的并行计算能力，导致性能低下。而 Vector API (Sixth Incubator) 的目标就是通过向量化计算来提高这些应用程序的性能。</p>
<h2 id="3-Vector-API-Sixth-Incubator- 的实现原理"><a href="#3-Vector-API-Sixth-Incubator- 的实现原理" class="headerlink" title="3. Vector API (Sixth Incubator) 的实现原理?"></a>3. Vector API (Sixth Incubator) 的实现原理?</h2><p>Vector API (Sixth Incubator) 基于 SIMD 指令集，即单指令多数据流指令集。SIMD 指令集可以同时对多个数据元素执行相同的操作，从而实现并行计算。Vector<br>API (Sixth Incubator) 提供了一组新的类和接口，使开发人员能够直接编写基于 SIMD 指令集的代码。</p>
<p>具体来说，Vector API (Sixth Incubator) 引入了 <code>java.util.vector</code> 包，其中包含了一些新的类和接口，如 <code>Vector</code>、<code>FloatVector</code><br>和 <code>IntVector</code> 等。这些类提供了一组向量化操作方法，例如加法、减法、乘法等，以及对应的掩码操作。</p>
<p>在底层实现上，Vector API (Sixth Incubator) 使用了特定硬件平台的 SIMD 指令集来执行向量化计算。具体实现细节会依赖于不同的硬件架构和操作系统。</p>
<h2 id="4-Vector-API-Sixth-Incubator- 的优点"><a href="#4-Vector-API-Sixth-Incubator- 的优点" class="headerlink" title="4. Vector API (Sixth Incubator) 的优点"></a>4. Vector API (Sixth Incubator) 的优点</h2><ul>
<li>提高性能：通过利用 SIMD 指令集进行并行计算，可以显著提高应用程序的性能。</li>
<li>简化编程模型：Vector API (Sixth Incubator) 提供了一组简单易用的类和接口，使开发人员能够直接编写基于 SIMD 指令集的代码，而无需手动优化。</li>
</ul>
<h2 id="5-Vector-API-Sixth-Incubator- 的缺点"><a href="#5-Vector-API-Sixth-Incubator- 的缺点" class="headerlink" title="5. Vector API (Sixth Incubator) 的缺点"></a>5. Vector API (Sixth Incubator) 的缺点</h2><ul>
<li>平台限制：Vector API (Sixth Incubator) 的实现依赖于特定的硬件平台和操作系统，因此在不同的平台上可能存在兼容性问题。</li>
<li>学习成本：使用 Vector API (Sixth Incubator) 需要学习新的类和接口，并理解 SIMD 指令集的工作原理，对于一些开发人员来说可能需要花费一定的时间和精力。</li>
</ul>
<h2 id="6-Vector-API-Sixth-Incubator- 的使用示例"><a href="#6-Vector-API-Sixth-Incubator- 的使用示例" class="headerlink" title="6. Vector API (Sixth Incubator) 的使用示例"></a>6. Vector API (Sixth Incubator) 的使用示例 </h2><p> 下面是一个简单的使用 Vector API (Sixth Incubator) 进行向量化计算的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.vector.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建两个向量对象</span></span><br><span class="line">        <span class="type">FloatVector</span> <span class="variable">a</span> <span class="operator">=</span> FloatVector.broadcast(size, <span class="number">2.0f</span>);</span><br><span class="line">        <span class="type">FloatVector</span> <span class="variable">b</span> <span class="operator">=</span> FloatVector.broadcast(size, <span class="number">3.0f</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行向量化加法操作</span></span><br><span class="line">        <span class="type">FloatVector</span> <span class="variable">result</span> <span class="operator">=</span> a.add(b);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="type">float</span>[] array = <span class="keyword">new</span> <span class="title class_">float</span>[size];</span><br><span class="line">        result.intoArray(array, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">float</span> value : array) &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了两个长度为 8 的浮点数向量，并执行了向量化的加法操作。最后将结果输出到数组中并打印出来。</p>
<h2 id="7-Vector-API-Sixth-Incubator- 的使用注意事项"><a href="#7-Vector-API-Sixth-Incubator- 的使用注意事项" class="headerlink" title="7. Vector API (Sixth Incubator) 的使用注意事项"></a>7. Vector API (Sixth Incubator) 的使用注意事项</h2><ul>
<li>硬件兼容性：由于 Vector API (Sixth Incubator) 的实现依赖于特定的硬件平台和操作系统，因此在使用之前需要确保目标平台支持<br>SIMD 指令集。</li>
<li>性能优化：虽然 Vector API (Sixth Incubator) 可以提高应用程序的性能，但要获得最佳性能还需要进行适当的优化。例如，避免频繁的向量化操作和数据拷贝等。</li>
</ul>
<h2 id="8- 总结 -10"><a href="#8- 总结 -10" class="headerlink" title="8. 总结"></a>8. 总结 </h2><p>Vector API (Sixth Incubator) 是 Java 平台的一个项目，旨在提供一种简单且高效的方式来执行向量化计算。它基于 SIMD<br> 指令集，并通过引入新的类和接口来支持并行计算。使用 Vector API (Sixth Incubator) 可以提高应用程序的性能，但需要注意硬件兼容性和适当的性能优化。</p>
<h1 id="449-Deprecate-the-Windows-32-bit-x86-Port-for-Removal"><a href="#449-Deprecate-the-Windows-32-bit-x86-Port-for-Removal" class="headerlink" title="| 449: | Deprecate the Windows 32-bit x86 Port for Removal |"></a>| 449: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/449">Deprecate the Windows 32-bit x86 Port for Removal</a> |</h1><p>名字太长了。。后面简称 449</p>
<h2 id="1- 什么是 JEP-449"><a href="#1- 什么是 JEP-449" class="headerlink" title="1. 什么是 JEP 449?"></a>1. 什么是 JEP 449?</h2><p>JEP 449（Java Enhancement Proposal 449）是一个针对 OpenJDK 的提案，旨在废弃并最终移除 Windows 32 位 x86 平台上的 Java 支持。</p>
<h2 id="2- 为什么需要废弃 Windows-32 位 x86 平台上的 Java 支持？"><a href="#2- 为什么需要废弃 Windows-32 位 x86 平台上的 Java 支持？" class="headerlink" title="2. 为什么需要废弃 Windows 32 位 x86 平台上的 Java 支持？"></a>2. 为什么需要废弃 Windows 32 位 x86 平台上的 Java 支持？</h2><p>主要有以下几个原因：</p>
<ul>
<li><strong>过时的硬件和操作系统</strong>：Windows 32 位 x86 平台已经逐渐被淘汰，现代计算机普遍采用 64 位架构。同时，大多数新版本的 Windows 操作系统也只提供了 64 位版本。</li>
<li><strong>性能限制</strong>：32 位架构限制了可寻址内存空间的大小，导致无法充分利用现代计算机的资源。而 64 位架构可以提供更大的内存地址空间，从而提高应用程序的性能和扩展性。</li>
<li><strong>安全问题</strong>：32 位架构存在一些安全漏洞和限制，例如缓冲区溢出等。而 64 位架构通过引入更多的保护机制来增加应用程序的安全性。</li>
</ul>
<p>基于以上原因，废弃 Windows 32 位 x86 平台上的 Java 支持是合理且必要的。</p>
<h2 id="3-JEP-449 的实现原理"><a href="#3-JEP-449 的实现原理" class="headerlink" title="3. JEP 449 的实现原理"></a>3. JEP 449 的实现原理</h2><p>JEP 449 的实现原理涉及到编译器、虚拟机和库等多个方面的改动。</p>
<ul>
<li><strong>编译器层面</strong>：废弃 32 位 x86 平台上的 Java 支持需要对编译器进行修改，禁止生成 32 位 x86 架构的目标代码。</li>
<li><strong>虚拟机层面</strong>：虚拟机需要对内存管理、垃圾回收等进行调整，以适应 64 位架构的特性。同时，还需要更新与操作系统交互的部分代码，确保在 64 位环境下正常运行。</li>
<li><strong>库层面</strong>：一些与硬件相关的库可能需要重新编写或者替换为 64 位版本，以充分利用 64 位架构的优势。</li>
</ul>
<p>具体实现细节可以参考 JEP 449 提案中的详细说明。</p>
<h2 id="4-JEP-449 的优点"><a href="#4-JEP-449 的优点" class="headerlink" title="4. JEP 449 的优点"></a>4. JEP 449 的优点</h2><ul>
<li><strong>性能提升</strong>：64 位架构可以提供更大的内存地址空间，从而提高应用程序的性能和扩展性。</li>
<li><strong>安全增强</strong>：64 位架构引入了更多的保护机制，提高了应用程序的安全性。</li>
<li><strong>与现代计算机趋势相符</strong>：Windows 32 位 x86 平台已经逐渐被淘汰，废弃该平台上的 Java 支持是与时俱进的举措。</li>
</ul>
<h2 id="5-JEP-449 的缺点"><a href="#5-JEP-449 的缺点" class="headerlink" title="5. JEP 449 的缺点"></a>5. JEP 449 的缺点</h2><ul>
<li><strong>向后兼容性问题</strong>：废弃 Windows 32 位 x86 平台上的 Java 支持可能导致一些现有的应用程序无法在该平台上运行。这需要开发人员进行相应的迁移和调整。</li>
<li>** 对于仍然使用 32 位硬件和操作系统的用户而言，将无法继续获得新版本的 Java 更新和功能改进。</li>
</ul>
<h2 id="6-JEP-449 的使用示例"><a href="#6-JEP-449 的使用示例" class="headerlink" title="6. JEP 449 的使用示例"></a>6. JEP 449 的使用示例</h2><p>JEP 449 是一个 OpenJDK 的提案，它主要影响到 OpenJDK 的开发者和 Windows 32 位 x86 平台上的 Java 用户。对于开发者来说，他们需要根据 JEP<br>449 的实施情况，适时地迁移和调整自己的应用程序代码。对于 Windows<br>32 位 x86 平台上的 Java 用户来说，他们需要考虑升级到 64 位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</p>
<h2 id="7-JEP-449 的使用注意事项"><a href="#7-JEP-449 的使用注意事项" class="headerlink" title="7. JEP 449 的使用注意事项"></a>7. JEP 449 的使用注意事项</h2><ul>
<li>开发者需要及时关注 JEP 449 的实施情况，并根据需要进行相应的迁移和调整。</li>
<li>Windows 32 位 x86 平台上的 Java 用户需要考虑升级到 64 位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</li>
</ul>
<h2 id="8- 总结 -11"><a href="#8- 总结 -11" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>JEP 449 旨在废弃并最终移除 Windows<br>32 位 x86 平台上的 Java 支持。这是基于该平台已经逐渐被淘汰、性能限制和安全问题等原因做出的合理举措。废弃该平台上的 Java 支持可以提高应用程序的性能和安全性，并与现代计算机趋势相符。开发者需要及时关注 JEP<br>449 的实施情况，并根据需要进行相应的迁移和调整。Windows 32 位 x86 平台上的 Java 用户需要考虑升级到 64 位架构的计算机和操作系统，以继续获得最新的 Java 更新和功能改进。</p>
<h1 id="451-Prepare-to-Disallow-the-Dynamic-Loading-of-Agents"><a href="#451-Prepare-to-Disallow-the-Dynamic-Loading-of-Agents" class="headerlink" title="| 451: | Prepare to Disallow the Dynamic Loading of Agents |"></a>| 451: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/451">Prepare to Disallow the Dynamic Loading of Agents</a> |</h1><h2 id="1- 什么是动态加载代理禁用准备（Prepare-to-Disallow-the-Dynamic-Loading-of-Agents）？"><a href="#1- 什么是动态加载代理禁用准备（Prepare-to-Disallow-the-Dynamic-Loading-of-Agents）？" class="headerlink" title="1. 什么是动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of Agents）？"></a>1. 什么是动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of Agents）？</h2><p>动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of<br>Agents）是一个 Java 增强提案，其目标是在 JVM 中禁止动态加载代理。代理是一种能够修改或监视应用程序行为的机制，它可以通过字节码注入来实现。</p>
<h2 id="2- 为什么需要动态加载代理禁用准备？"><a href="#2- 为什么需要动态加载代理禁用准备？" class="headerlink" title="2. 为什么需要动态加载代理禁用准备？"></a>2. 为什么需要动态加载代理禁用准备？</h2><p>动态加载代理允许开发人员在运行时修改和监视 Java 应用程序的行为。虽然这对于调试和性能分析等方面非常有用，但也存在潜在的安全风险。恶意代码可能会利用动态加载代理的功能来执行恶意操作，例如窃取敏感信息、篡改数据等。</p>
<p>因此，为了加强 Java 应用程序的安全性，限制动态加载代理的使用是很有必要的。</p>
<h2 id="3- 动态加载代理禁用准备的实现原理"><a href="#3- 动态加载代理禁用准备的实现原理" class="headerlink" title="3. 动态加载代理禁用准备的实现原理"></a>3. 动态加载代理禁用准备的实现原理 </h2><p> 动态加载代理禁用准备的实现涉及到以下几个方面：</p>
<h3 id="3-1- 修改 ClassLoader"><a href="#3-1- 修改 ClassLoader" class="headerlink" title="3.1 修改 ClassLoader"></a>3.1 修改 ClassLoader</h3><p>该提案建议修改 Java 虚拟机的类加载器，以阻止动态加载代理。具体而言，将在 <code>java.lang.ClassLoader</code><br> 类中添加一个新的方法<code>boolean disallowDynamicAgentLoading()</code>，默认返回<code>false</code>。当该方法被调用时，将返回<code>true</code>，表示禁止动态加载代理。</p>
<h3 id="3-2- 修改 Instrumentation-API"><a href="#3-2- 修改 Instrumentation-API" class="headerlink" title="3.2 修改 Instrumentation API"></a>3.2 修改 Instrumentation API</h3><p>为了支持 ClassLoader 的修改，还需要对 Java 虚拟机的 Instrumentation<br>API 进行相应的更改。具体而言，将在 <code>java.lang.instrument.Instrumentation</code><br> 接口中添加一个新的方法 <code>boolean isDynamicAgentLoadingAllowed()</code>，默认返回<code>true</code>。当该方法返回<code>false</code> 时，表示禁止动态加载代理。</p>
<h3 id="3-3- 更新安全管理器"><a href="#3-3- 更新安全管理器" class="headerlink" title="3.3 更新安全管理器"></a>3.3 更新安全管理器 </h3><p> 此外，还建议更新 Java 虚拟机的安全管理器（SecurityManager），以允许检查是否允许动态加载代理。这样可以通过安全策略来控制哪些代码可以使用动态加载代理功能。</p>
<h2 id="4- 动态加载代理禁用准备的优点"><a href="#4- 动态加载代理禁用准备的优点" class="headerlink" title="4. 动态加载代理禁用准备的优点"></a>4. 动态加载代理禁用准备的优点</h2><ul>
<li>提高 Java 应用程序的安全性：禁止动态加载代理可以防止恶意代码利用其功能执行潜在的危险操作。</li>
<li>简化安全配置：通过更新安全管理器和类加载器，可以更方便地控制动态加载代理的使用权限，简化安全配置过程。</li>
</ul>
<h2 id="5- 动态加载代理禁用准备的缺点"><a href="#5- 动态加载代理禁用准备的缺点" class="headerlink" title="5. 动态加载代理禁用准备的缺点"></a>5. 动态加载代理禁用准备的缺点</h2><ul>
<li>可能影响现有代码：如果现有代码依赖于动态加载代理的功能，那么禁用它可能会导致这些代码无法正常工作。因此，在应用该增强提案之前，需要仔细评估现有代码的依赖关系。</li>
</ul>
<h2 id="6- 动态加载代理禁用准备的使用示例"><a href="#6- 动态加载代理禁用准备的使用示例" class="headerlink" title="6. 动态加载代理禁用准备的使用示例"></a>6. 动态加载代理禁用准备的使用示例 </h2><p> 以下是一个简单的示例，展示了如何使用动态加载代理禁用准备：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> &#123;</span><br><span class="line">        <span class="comment">// 禁止动态加载代理</span></span><br><span class="line">        <span class="keyword">if</span> (inst.isDynamicAgentLoadingAllowed()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SecurityException</span>(<span class="string">&quot;Dynamic loading of agents is not allowed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他初始化操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>premain</code>方法是 Java 代理的入口点。通过调用 <code>isDynamicAgentLoadingAllowed()</code> 方法，可以检查是否允许动态加载代理。如果不允许，则抛出安全异常。</p>
<h2 id="7- 动态加载代理禁用准备的使用注意事项"><a href="#7- 动态加载代理禁用准备的使用注意事项" class="headerlink" title="7. 动态加载代理禁用准备的使用注意事项"></a>7. 动态加载代理禁用准备的使用注意事项</h2><ul>
<li>在使用动态加载代理禁用准备之前，需要仔细评估现有代码是否依赖于动态加载代理的功能。</li>
<li>需要更新相关的类加载器和安全管理器来支持禁止动态加载代理的功能。</li>
<li>使用动态加载代理禁用准备时，需要确保应用程序的安全策略能够正确地控制动态加载代理的使用权限。</li>
</ul>
<h2 id="8- 总结 -12"><a href="#8- 总结 -12" class="headerlink" title="8. 总结"></a>8. 总结 </h2><p> 动态加载代理禁用准备是一个 Java 增强提案，旨在禁止动态加载代理以提高应用程序的安全性。它通过修改类加载器、Instrumentation<br>API 和安全管理器来实现禁止动态加载代理的功能。尽管这样做可以增加应用程序的安全性，但也可能影响依赖于动态加载代理的现有代码。因此，在使用该功能之前需要仔细评估现有代码的依赖关系。</p>
<h1 id="452-Key-Encapsulation-Mechanism-API"><a href="#452-Key-Encapsulation-Mechanism-API" class="headerlink" title="| 452: | Key Encapsulation Mechanism API |"></a>| 452: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/452">Key Encapsulation Mechanism API</a> |</h1><h2 id="1- 什么是 Key-Encapsulation-Mechanism-API"><a href="#1- 什么是 Key-Encapsulation-Mechanism-API" class="headerlink" title="1. 什么是 Key Encapsulation Mechanism API?"></a>1. 什么是 Key Encapsulation Mechanism API?</h2><p>Key Encapsulation Mechanism (KEM) API 是一个 Java<br>API，用于支持密钥封装机制。密钥封装是一种加密技术，它将一个对称密钥（也称为会话密钥）与公钥结合使用，以便在不直接暴露私钥的情况下安全地传输密钥。</p>
<p>KEM API 提供了一组方法和类，用于生成、封装和解封装密钥。它可以与现有的密码学算法和协议集成，提供更高级别的密钥管理功能。</p>
<h2 id="2- 为什么需要 Key-Encapsulation-Mechanism-API"><a href="#2- 为什么需要 Key-Encapsulation-Mechanism-API" class="headerlink" title="2. 为什么需要 Key Encapsulation Mechanism API?"></a>2. 为什么需要 Key Encapsulation Mechanism API?</h2><p>在传统的密钥交换过程中，通常需要事先共享或分发密钥。这可能存在许多安全风险，例如密钥泄露、中间人攻击等。而密钥封装机制通过使用公钥进行密钥交换，避免了这些问题。</p>
<p>Key Encapsulation Mechanism API 的出现使得开发者能够更方便地实现密钥封装机制，并提供了更高级别的密钥管理功能。它简化了密钥生成、封装和解封装的过程，同时保证了安全性和可靠性。</p>
<h2 id="3-Key-Encapsulation-Mechanism-API 的实现原理"><a href="#3-Key-Encapsulation-Mechanism-API 的实现原理" class="headerlink" title="3. Key Encapsulation Mechanism API 的实现原理"></a>3. Key Encapsulation Mechanism API 的实现原理</h2><p>Key Encapsulation Mechanism API 的实现原理基于非对称加密算法和密钥封装机制。它使用公钥进行密钥交换，并通过将会话密钥封装在一个安全的密文中，以确保密钥的安全传输。</p>
<p>具体实现过程如下：</p>
<ol>
<li>生成一对公私钥对。</li>
<li>使用公钥进行密钥封装，生成一个密文。</li>
<li>将密文发送给接收方。</li>
<li>接收方使用私钥解封装密文，得到会话密钥。</li>
<li>双方可以使用会话密钥进行加密通信。</li>
</ol>
<h2 id="4-Key-Encapsulation-Mechanism-API 的优点"><a href="#4-Key-Encapsulation-Mechanism-API 的优点" class="headerlink" title="4. Key Encapsulation Mechanism API 的优点"></a>4. Key Encapsulation Mechanism API 的优点</h2><ul>
<li><strong>安全性高</strong>：Key Encapsulation Mechanism API 使用了非对称加密算法和密钥封装机制，能够提供较高的安全性，避免了密钥泄露和中间人攻击等问题。</li>
<li><strong>易于使用</strong>：API 提供了简单易用的方法和类，开发者可以轻松地生成、封装和解封装密钥，无需深入了解底层算法和协议。</li>
<li><strong>灵活性强</strong>：API 可以与现有的密码学算法和协议集成，提供更高级别的密钥管理功能，满足不同场景的需求。</li>
</ul>
<h2 id="5-Key-Encapsulation-Mechanism-API 的缺点"><a href="#5-Key-Encapsulation-Mechanism-API 的缺点" class="headerlink" title="5. Key Encapsulation Mechanism API 的缺点"></a>5. Key Encapsulation Mechanism API 的缺点</h2><ul>
<li><strong>依赖于非对称加密算法</strong>：Key Encapsulation Mechanism API 的实现依赖于非对称加密算法，这些算法可能存在性能上的瓶颈和限制。</li>
<li><strong>需要保护私钥的安全</strong>：由于使用了非对称加密算法，私钥的安全至关重要。开发者需要采取措施来保护私钥的机密性和完整性。</li>
</ul>
<h2 id="6-Key-Encapsulation-Mechanism-API 的使用示例"><a href="#6-Key-Encapsulation-Mechanism-API 的使用示例" class="headerlink" title="6. Key Encapsulation Mechanism API 的使用示例"></a>6. Key Encapsulation Mechanism API 的使用示例 </h2><p> 下面是一个简单的使用示例，演示了如何使用 Key Encapsulation Mechanism API 进行密钥封装和解封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPairGenerator;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyAgreement;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KEMExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 生成公私钥对</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 KeyAgreement 对象</span></span><br><span class="line">        <span class="type">KeyAgreement</span> <span class="variable">keyAgreement</span> <span class="operator">=</span> KeyAgreement.getInstance(<span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        keyAgreement.init(keyPair.getPrivate());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行密钥协商过程</span></span><br><span class="line">        keyAgreement.doPhase(keyPair.getPublic(), <span class="literal">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成会话密钥</span></span><br><span class="line">        <span class="type">byte</span>[] sharedSecret = keyAgreement.generateSecret();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 封装会话密钥</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;AES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.WRAP_MODE, keyPair.getPublic());</span><br><span class="line">        <span class="type">byte</span>[] wrappedKey = cipher.wrap(sharedSecret);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解封装会话密钥</span></span><br><span class="line">        cipher.init(Cipher.UNWRAP_MODE, keyPair.getPrivate());</span><br><span class="line">        <span class="type">byte</span>[] unwrappedKey = cipher.unwrap(wrappedKey, <span class="string">&quot;AES&quot;</span>, Cipher.SECRET_KEY);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Shared Secret: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(sharedSecret));</span><br><span class="line">        System.out.println(<span class="string">&quot;Unwrapped Key: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(unwrappedKey));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-Key-Encapsulation-Mechanism-API 的使用注意事项"><a href="#7-Key-Encapsulation-Mechanism-API 的使用注意事项" class="headerlink" title="7. Key Encapsulation Mechanism API 的使用注意事项"></a>7. Key Encapsulation Mechanism API 的使用注意事项</h2><ul>
<li>开发者需要选择合适的非对称加密算法和密钥封装机制，根据具体需求进行配置。</li>
<li>私钥的安全至关重要，开发者应该采取措施来保护私钥的机密性和完整性。</li>
<li>密钥封装过程中生成的密文需要通过安全信道传输，以确保密钥的安全性。</li>
</ul>
<h2 id="8- 总结 -13"><a href="#8- 总结 -13" class="headerlink" title="8. 总结"></a>8. 总结 </h2><p>Key Encapsulation Mechanism API 是一个用于支持密钥封装机制的 Java<br>API。它提供了一组方法和类，用于生成、封装和解封装密钥。通过使用公钥进行密钥交换，避免了传统密钥交换方式中存在的安全风险。API<br> 的实现原理基于非对称加密算法和密钥封装机制，能够提供较高的安全性和灵活性。开发者可以轻松地使用 API<br>进行密钥封装和解封装操作，并与现有的密码学算法和协议集成，满足不同场景的需求。然而，API 的使用需要注意私钥的安全性和密文的传输安全。</p>
<h1 id="453-Structured-Concurrency-Preview"><a href="#453-Structured-Concurrency-Preview" class="headerlink" title="| 453: | Structured Concurrency (Preview) |"></a>| 453: | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/453">Structured Concurrency (Preview)</a> |</h1><h1 id="什么是结构化并发（Structured-Concurrency）？"><a href="# 什么是结构化并发（Structured-Concurrency）？" class="headerlink" title="什么是结构化并发（Structured Concurrency）？"></a>什么是结构化并发（Structured Concurrency）？</h1><p>结构化并发是一种用于简化并发编程的 API。它将在不同线程中运行的相关任务组视为一个单独的工作单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。</p>
<h1 id="为什么需要结构化并发？"><a href="# 为什么需要结构化并发？" class="headerlink" title="为什么需要结构化并发？"></a>为什么需要结构化并发？</h1><p>传统的并发编程模型，如<code>ExecutorService</code><br>API，由于其无限制的并发模式，引入了复杂性和风险。这些模型没有强制执行或跟踪任务和子任务之间的关系，使得管理和观察并发任务变得困难。结构化并发模型认为任务结构应该反映代码结构，在单线程代码中，执行总是强制实施任务和子任务的层次结构，每个子任务的生命周期相对于其他子任务受到代码的语法块结构的控制。</p>
<p>结构化并发旨在消除与并发编程相关的常见风险，例如线程泄漏和取消延迟，并增强并发代码的可观察性。</p>
<h1 id="结构化并发的实现原理"><a href="# 结构化并发的实现原理" class="headerlink" title="结构化并发的实现原理"></a>结构化并发的实现原理 </h1><p> 结构化并发通过引入新的 API 来实现，其中最重要的类是 <code>StructuredTaskScope</code>。<code>StructuredTaskScope</code><br> 封装了一组相关的任务，这些任务应该一起完成，如果任何子任务失败，则会取消剩余的子任务。</p>
<p>在结构化并发中，使用 <code>StructuredTaskScope</code><br> 创建一个作用域，在该作用域内可以派生出多个子任务。这些子任务将被视为整体，并且它们之间存在依赖关系。当所有子任务完成后，可以对它们进行处理，例如获取结果或抛出异常。</p>
<h1 id="结构化并发的优点"><a href="# 结构化并发的优点" class="headerlink" title="结构化并发的优点"></a>结构化并发的优点</h1><ul>
<li>简化并发编程：结构化并发提供了一种更简单、更直观的方式来处理并发任务。</li>
<li>错误处理和取消操作：通过将相关任务组合成一个单元，结构化并发使错误处理和取消操作更加容易和可靠。</li>
<li>提高可靠性：结构化并发模型消除了常见的风险，如线程泄漏和取消延迟，从而提高了并发代码的可靠性。</li>
<li>增强可观察性：结构化并发模型使得观察并发任务的执行状态变得更加方便。</li>
</ul>
<h1 id="结构化并发的缺点"><a href="# 结构化并发的缺点" class="headerlink" title="结构化并发的缺点"></a>结构化并发的缺点</h1><ul>
<li>预览功能：目前，结构化并发仍处于预览阶段，需要启用预览功能才能使用。</li>
</ul>
<h1 id="结构化并发的使用示例"><a href="# 结构化并发的使用示例" class="headerlink" title="结构化并发的使用示例"></a>结构化并发的使用示例 </h1><p> 下面是一个使用结构化并发的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Response <span class="title function_">handle</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">var</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;</span><br><span class="line">        Supplier&lt;String&gt;  user  = scope.fork(() -&gt; findUser());</span><br><span class="line">        Supplier&lt;Integer&gt; order = scope.fork(() -&gt; fetchOrder());</span><br><span class="line"></span><br><span class="line">        scope.join()            </span><br><span class="line">             .throwIfFailed();  </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(user.get(), order.get());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个新的 <code>StructuredTaskScope</code> 作用域，并使用它派生了两个子任务：一个执行 <code>findUser()</code><br> 方法，另一个执行 <code>fetchOrder()</code> 方法。一旦两个子任务都完成，就可以使用它们的结果创建一个新的 <code>Response</code> 对象。</p>
<h1 id="结构化并发的使用注意事项"><a href="# 结构化并发的使用注意事项" class="headerlink" title="结构化并发的使用注意事项"></a>结构化并发的使用注意事项</h1><ul>
<li>结构化并发是一个预览功能，默认情况下被禁用。要使用<code>StructuredTaskScope</code> API，开发人员必须启用预览功能来编译代码。</li>
<li>使用结构化并发时，通常不直接使用 <code>StructuredTaskScope</code><br> 类，而是使用实现关闭策略的两个子类之一。这些子类分别是 <code>ShutdownOnFailure</code> 和<code>ShutdownOnSuccess</code>，支持当第一个子任务失败或成功时关闭作用域的模式。</li>
<li>运行结构化并发程序时，需要使用 <code>--enable-preview</code> 选项启用预览功能。</li>
</ul>
<h1 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结 </h1><p> 结构化并发是一种用于简化并发编程的 API，它将相关任务组合成一个单元，从而简化错误处理和取消操作，提高可靠性，并增强可观察性。通过引入 <code>StructuredTaskScope</code><br> 类和相关的子类，结构化并发提供了一种更简单、更直观的方式来处理并发任务。然而，需要注意的是，结构化并发目前仍处于预览阶段，并且需要启用预览功能才能使用。</p>
<p>JDK 21 将是大多数供应商的长期支持 （LTS） 版本。有关自上一个 LTS 版本 JDK 17 以来集成的 JEP<br>的完整列表，请参阅 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/projects/jdk/21/jeps-since-jdk-17">here</a>.</p>
<p>Schedule</p>
<hr>
<blockquote>
<p>| 2023&#x2F;06&#x2F;08 | | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/3#rdp-1">第一阶段缓慢降级 </a>（从主分支派生）|<br>| 2023&#x2F;07&#x2F;20 | | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/3#rdp-2"> 第二阶段缓慢降级 </a>|<br>| 2023&#x2F;08&#x2F;10 | | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/3#rc"> 初始候选发行版 </a>|<br>| 2023&#x2F;08&#x2F;24 | | <a target="_blank" rel="noopener external nofollow noreferrer" href="https://openjdk.org/jeps/3#rc"> 最终候选发行版</a>|<br>| 2023&#x2F;09&#x2F;19 | | 正式发布 |</p>
</blockquote>
<p>最后更新时间：2023 年 9 月 19 日 10:53 UTC</p>
</div><script src="https://cdn.jsdelivr.net/lightgallery.js/1.0.1/js/lightgallery.min.js"></script><script>if (typeof lightGallery !== 'undefined') {
        var options = {selector: '.gallery-item'};
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options);
        }</script></div>
				<link rel="stylesheet" type="text/css" href="https://qiniu.techgrow.cn/readmore/dist/hexo.css">
				<script src="https://qiniu.techgrow.cn/readmore/dist/readmore.js" type="text/javascript"></script>
				<script>
				var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
				var isEncrypt = document.getElementById('hexo-blog-encrypt');
				var allowMobile = false;
				if (!isEncrypt && (!isMobile || (isMobile && allowMobile))) {
					try {
						var plugin = new ReadmorePlugin();
						plugin.init({
							"type": "hexo",
							"id": "readmore-container",
							"name": "程序员朱永胜",
							"blogId": "39259-6450029321246-893",
							"qrcode": "https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142242856.jpg",
							"keyword": "1",
							"random": "1",
							"height": "auto",
							"expires": "365",
							"lockToc": "yes",
							"interval": "60",
							"baseUrl": ""
						});
					} catch(e) {
						console.warn("readmore plugin occurred error: " + e.name + " | " + e.message);
					}
				}
				</script>
			</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="index.html" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/aliyun/202308012321669.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/aliyun/202308012321669.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">程序员朱永胜</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blog.zysicyj.top/752ac5dd.html">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blog.zysicyj.top/752ac5dd.html')">JDK21 更新特性详解</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142337659.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142337659.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142338230.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/blog/202308142338230.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blog.zysicyj.top/752ac5dd.html"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=https://blog.zysicyj.top/752ac5dd.html&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.zysicyj.top" target="_blank"></a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"></div><div class="post_share"><div class="social-share" data-image="https://img.xjh.me/random_img.php?return=302&amp;_r_=9189c559-4895-4a6c-988b-1e1b44ec4c54" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="today_2023_09.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&amp;_r_=ca5b344d-90c6-4861-df03-e0482e54d911" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Today For 2023 年 9 月</div></div></a></div><div class="next-post pull-right"><a href="e4b87107.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&amp;_r_=94d2102d-9cae-a337-5ee2-4851f01f7684" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Springboot 应用异常处理</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="dbf2c6e9.html" title="JDK21 更新内容：结构化并发编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&_r_=61b75bc0-fd60-9837-f9d0-35032e661d7a" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2025-01-22</div><div class="title">JDK21 更新内容：结构化并发编程</div></div></a></div><div><a href="369b115a.html" title="JDK21 更新内容：SequenceCollection"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&_r_=24e6f2ab-5690-a3ee-4687-4e7ed67a7705" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2025-01-22</div><div class="title">JDK21 更新内容：SequenceCollection</div></div></a></div><div><a href="6e4b1dfc.html" title="Java 和 C++ 的区别?"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&_r_=dd4a1de6-3118-edbf-17c2-fb5d196b61f4" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2025-01-22</div><div class="title">Java 和 C++ 的区别?</div></div></a></div><div><a href="4a9cec5e.html" title="JDK21 更新内容：RedordPatterns"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&_r_=e2265d80-8c9c-bd35-316e-a8ef0c3a0160" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2025-01-22</div><div class="title">JDK21 更新内容：RedordPatterns</div></div></a></div><div><a href="5ee71a5e.html" title="EasyCode 自动生成脚本"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&_r_=df0a5b63-6d69-609b-1c46-7e33ced2d3a1" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2025-01-22</div><div class="title">EasyCode 自动生成脚本</div></div></a></div><div><a href="a3047fae.html" title="JavaOptional 用法"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&_r_=5fdc0b74-f5b5-58ec-995d-c5bfc1ddec26" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2025-01-22</div><div class="title">JavaOptional 用法</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/aliyun/202308012321669.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">这有关于<b style="color:#fff">产品、设计、开发</b>相关的问题和看法，还有<b style="color:#fff">文章翻译</b>和<b style="color:#fff">分享</b>。</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">相信你可以在这里找到对你有用的<b style="color:#fff">知识</b>和<b style="color:#fff">教程</b>。</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/about"><h1 class="author-info__name">程序员朱永胜</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="mailto:zhuyongsheng@xxc99.cn" rel="external nofollow noreferrer" target="_blank" title="fas fa-envelope"></a><a class="social-icon faa-parent animated-hover" href="https://blog.csdn.net/njpkhuan" rel="external nofollow noreferrer" target="_blank" title="fa-solid fa-blog fa-beat"></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/258577429" rel="external nofollow noreferrer" target="_blank" title="fa-brands fa-bilibili"></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://img02.anheyu.com/adminuploads/1/2022/09/11/631ddb7c9b250.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://blog-1253652709.cos.ap-guangzhou.myqcloud.com/tc/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#430-String-Templates-Preview"><span class="toc-number">1.</span> <span class="toc-text">| 430: | String Templates (Preview) |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20String-Templates"><span class="toc-number">1.1.</span> <span class="toc-text">1. 什么是 String Templates?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20String-Templates"><span class="toc-number">1.2.</span> <span class="toc-text">2. 为什么需要 String Templates?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-String-Templates%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">3. String Templates 的实现原理?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-String-Templates%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.4.</span> <span class="toc-text">4. String Templates 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-String-Templates%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">5. String Templates 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-String-Templates%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.</span> <span class="toc-text">6. String Templates 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-String-Templates%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.7.</span> <span class="toc-text">7. String Templates 的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93"><span class="toc-number">1.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#431-Sequenced-Collections"><span class="toc-number">2.</span> <span class="toc-text">| 431: | Sequenced Collections |</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Sequenced-Collections"><span class="toc-number">3.</span> <span class="toc-text">Sequenced Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Sequenced-Collections%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">1. 什么是 Sequenced Collections？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Sequenced-Collections%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2. 为什么需要 Sequenced Collections？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Sequenced-Collections%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">3. Sequenced Collections 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Sequenced-Collections%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">3.4.</span> <span class="toc-text">4. Sequenced Collections 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Sequenced-Collections%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">3.5.</span> <span class="toc-text">5. Sequenced Collections 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Sequenced-Collections%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.6.</span> <span class="toc-text">6. Sequenced Collections 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Sequenced-Collections%20%E7%9A%84%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.7.</span> <span class="toc-text">7. Sequenced Collections 的其他注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-1"><span class="toc-number">3.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#439-Generational-ZGC"><span class="toc-number">4.</span> <span class="toc-text">| 439: | Generational ZGC |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Generational-ZGC"><span class="toc-number">4.1.</span> <span class="toc-text">1. 什么是 Generational ZGC?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Generational-ZGC"><span class="toc-number">4.2.</span> <span class="toc-text">2. 为什么需要 Generational ZGC?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Generational-ZGC%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.3.</span> <span class="toc-text">3. Generational ZGC 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B4%E8%BD%BB%E4%BB%A3%EF%BC%88Young-Generation%EF%BC%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">年轻代（Young Generation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3%EF%BC%88Old-Generation%EF%BC%89"><span class="toc-number">4.3.2.</span> <span class="toc-text">老年代（Old Generation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="toc-number">4.3.3.</span> <span class="toc-text">并发处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Generational-ZGC%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.4.</span> <span class="toc-text">4. Generational ZGC 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Generational-ZGC%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">4.5.</span> <span class="toc-text">5. Generational ZGC 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Generational-ZGC%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.6.</span> <span class="toc-text">6. Generational ZGC 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Generational-ZGC%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.7.</span> <span class="toc-text">7. Generational ZGC 的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-2"><span class="toc-number">4.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#440-Record-Patterns"><span class="toc-number">5.</span> <span class="toc-text">| 440: | Record Patterns |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Record-Patterns"><span class="toc-number">5.1.</span> <span class="toc-text">1. 什么是 Record Patterns?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Record-Patterns"><span class="toc-number">5.2.</span> <span class="toc-text">2. 为什么需要 Record Patterns?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Record-Patterns-%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.</span> <span class="toc-text">3. Record Patterns 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.3.1.</span> <span class="toc-text">记录类型 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">5.3.2.</span> <span class="toc-text">模式匹配 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Record-Patterns-%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">5.4.</span> <span class="toc-text">4. Record Patterns 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Record-Patterns-%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">5.5.</span> <span class="toc-text">5. Record Patterns 的缺点 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Record-Patterns-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.6.</span> <span class="toc-text">6. Record Patterns 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Record-Patterns-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.7.</span> <span class="toc-text">7. Record Patterns 的使用注意事项 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-3"><span class="toc-number">5.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#441-Pattern-Matching-for-switch"><span class="toc-number">6.</span> <span class="toc-text">| 441: | Pattern Matching for switch |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20-Pattern-Matching-for-switch"><span class="toc-number">6.1.</span> <span class="toc-text">1. 什么是 Pattern Matching for switch?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20-Pattern-Matching-for-switch"><span class="toc-number">6.2.</span> <span class="toc-text">2. 为什么需要 Pattern Matching for switch?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Pattern-Matching-for-switch-%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">3. Pattern Matching for switch 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%20-1"><span class="toc-number">6.3.1.</span> <span class="toc-text">模式匹配 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">6.3.2.</span> <span class="toc-text">类型推断 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Pattern-Matching-for-switch-%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.4.</span> <span class="toc-text">4. Pattern Matching for switch 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Pattern-Matching-for-switch-%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.5.</span> <span class="toc-text">5. Pattern Matching for switch 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Pattern-Matching-for-switch-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.6.</span> <span class="toc-text">6. Pattern Matching for switch 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Pattern-Matching-for-switch-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.7.</span> <span class="toc-text">7. Pattern Matching for switch 的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-4"><span class="toc-number">6.8.</span> <span class="toc-text">8. 总结 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#442-Foreign-Function-Memory-API-Third-Preview"><span class="toc-number">7.</span> <span class="toc-text">| 442: | Foreign Function &amp; Memory API (Third Preview) |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Foreign-Function-Memory-API-Third-Preview"><span class="toc-number">7.1.</span> <span class="toc-text">1. 什么是 Foreign Function &amp; Memory API (Third Preview)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Foreign-Function-Memory-API"><span class="toc-number">7.2.</span> <span class="toc-text">2. 为什么需要 Foreign Function &amp; Memory API?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Foreign-Function-Memory-API-%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">3. Foreign Function &amp; Memory API 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Foreign-Function-Memory-API-%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">7.4.</span> <span class="toc-text">4. Foreign Function &amp; Memory API 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Foreign-Function-Memory-API-%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">7.5.</span> <span class="toc-text">5. Foreign Function &amp; Memory API 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Foreign-Function-Memory-API-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.6.</span> <span class="toc-text">6. Foreign Function &amp; Memory API 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Foreign-Function-Memory-API-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.7.</span> <span class="toc-text">7. Foreign Function &amp; Memory API 的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-5"><span class="toc-number">7.8.</span> <span class="toc-text">8. 总结 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#443-Unnamed-Patterns-and-Variables-Preview"><span class="toc-number">8.</span> <span class="toc-text">| 443: | Unnamed Patterns and Variables (Preview) |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Unnamed-Patterns-and-Variables-Preview"><span class="toc-number">8.1.</span> <span class="toc-text">1. 什么是 Unnamed Patterns and Variables (Preview)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Unnamed-Patterns-and-Variables"><span class="toc-number">8.2.</span> <span class="toc-text">2. 为什么需要 Unnamed Patterns and Variables?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Unnamed-Patterns-and-Variables-%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">3. Unnamed Patterns and Variables 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.3.1.</span> <span class="toc-text">匿名模式 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%8F%98%E9%87%8F"><span class="toc-number">8.3.2.</span> <span class="toc-text">匿名变量 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Unnamed-Patterns-and-Variables-%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">8.4.</span> <span class="toc-text">4. Unnamed Patterns and Variables 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Unnamed-Patterns-and-Variables-%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">8.5.</span> <span class="toc-text">5. Unnamed Patterns and Variables 的缺点 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Unnamed-Patterns-and-Variables-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.6.</span> <span class="toc-text">6. Unnamed Patterns and Variables 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Unnamed-Patterns-and-Variables-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.7.</span> <span class="toc-text">7. Unnamed Patterns and Variables 的使用注意事项 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-6"><span class="toc-number">8.8.</span> <span class="toc-text">8. 总结 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#444-Virtual-Threads"><span class="toc-number">9.</span> <span class="toc-text">| 444: | Virtual Threads |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Virtual-Threads"><span class="toc-number">9.1.</span> <span class="toc-text">1. 什么是 Virtual Threads?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Virtual-Threads"><span class="toc-number">9.2.</span> <span class="toc-text">2. 为什么需要 Virtual Threads?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Virtual-Threads%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">3. Virtual Threads 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Virtual-Threads%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">9.4.</span> <span class="toc-text">4. Virtual Threads 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Virtual-Threads%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">9.5.</span> <span class="toc-text">5. Virtual Threads 的缺点 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Virtual-Threads%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.6.</span> <span class="toc-text">6. Virtual Threads 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Virtual-Threads%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">9.7.</span> <span class="toc-text">7. Virtual Threads 的使用注意事项 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-7"><span class="toc-number">9.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#445-Unnamed-Classes-and-Instance-Main-Methods-Preview"><span class="toc-number">10.</span> <span class="toc-text">| 445: | Unnamed Classes and Instance Main Methods (Preview) |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Unnamed-Classes-and-Instance-Main-Methods-Preview"><span class="toc-number">10.1.</span> <span class="toc-text">1. 什么是 Unnamed Classes and Instance Main Methods (Preview)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Unnamed-Classes-and-Instance-Main-Methods"><span class="toc-number">10.2.</span> <span class="toc-text">2. 为什么需要 Unnamed Classes and Instance Main Methods?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Unnamed-Classes-and-Instance-Main-Methods-%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.3.</span> <span class="toc-text">3. Unnamed Classes and Instance Main Methods 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%20%E5%8C%BF%E5%90%8D%E7%B1%BB"><span class="toc-number">10.3.1.</span> <span class="toc-text">3.1 匿名类 </span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%20%E5%AE%9E%E4%BE%8B%E4%B8%BB%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.2.</span> <span class="toc-text">3.2 实例主方法 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Unnamed-Classes-and-Instance-Main-Methods-%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">10.4.</span> <span class="toc-text">4. Unnamed Classes and Instance Main Methods 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Unnamed-Classes-and-Instance-Main-Methods-%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">10.5.</span> <span class="toc-text">5. Unnamed Classes and Instance Main Methods 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Unnamed-Classes-and-Instance-Main-Methods-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.6.</span> <span class="toc-text">6. Unnamed Classes and Instance Main Methods 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Unnamed-Classes-and-Instance-Main-Methods-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">10.7.</span> <span class="toc-text">7. Unnamed Classes and Instance Main Methods 的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-8"><span class="toc-number">10.8.</span> <span class="toc-text">8. 总结 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#446-Scoped-Values-Preview"><span class="toc-number">11.</span> <span class="toc-text">| 446: | Scoped Values (Preview) |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Scoped-Values-Preview"><span class="toc-number">11.1.</span> <span class="toc-text">1. 什么是 Scoped Values (Preview)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Scoped-Values-Preview"><span class="toc-number">11.2.</span> <span class="toc-text">2. 为什么需要 Scoped Values (Preview)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Scoped-Values-Preview-%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">3. Scoped Values (Preview) 的实现原理?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Scoped-Values-Preview-%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">11.4.</span> <span class="toc-text">4. Scoped Values (Preview) 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Scoped-Values-Preview-%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">11.5.</span> <span class="toc-text">5. Scoped Values (Preview) 的缺点 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Scoped-Values-Preview-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.6.</span> <span class="toc-text">6. Scoped Values (Preview) 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Scoped-Values-Preview-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">11.7.</span> <span class="toc-text">7. Scoped Values (Preview) 的使用注意事项 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-9"><span class="toc-number">11.8.</span> <span class="toc-text">8. 总结 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#448-Vector-API-Sixth-Incubator"><span class="toc-number">12.</span> <span class="toc-text">| 448: | Vector API (Sixth Incubator) |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Vector-API-Sixth-Incubator"><span class="toc-number">12.1.</span> <span class="toc-text">1. 什么是 Vector API (Sixth Incubator)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Vector-API-Sixth-Incubator"><span class="toc-number">12.2.</span> <span class="toc-text">2. 为什么需要 Vector API (Sixth Incubator)?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Vector-API-Sixth-Incubator-%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">12.3.</span> <span class="toc-text">3. Vector API (Sixth Incubator) 的实现原理?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Vector-API-Sixth-Incubator-%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">12.4.</span> <span class="toc-text">4. Vector API (Sixth Incubator) 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Vector-API-Sixth-Incubator-%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">12.5.</span> <span class="toc-text">5. Vector API (Sixth Incubator) 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Vector-API-Sixth-Incubator-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.6.</span> <span class="toc-text">6. Vector API (Sixth Incubator) 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Vector-API-Sixth-Incubator-%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">12.7.</span> <span class="toc-text">7. Vector API (Sixth Incubator) 的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-10"><span class="toc-number">12.8.</span> <span class="toc-text">8. 总结 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#449-Deprecate-the-Windows-32-bit-x86-Port-for-Removal"><span class="toc-number">13.</span> <span class="toc-text">| 449: | Deprecate the Windows 32-bit x86 Port for Removal |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20JEP-449"><span class="toc-number">13.1.</span> <span class="toc-text">1. 什么是 JEP 449?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BA%9F%E5%BC%83%20Windows-32%20%E4%BD%8D%20x86%20%E5%B9%B3%E5%8F%B0%E4%B8%8A%E7%9A%84%20Java%20%E6%94%AF%E6%8C%81%EF%BC%9F"><span class="toc-number">13.2.</span> <span class="toc-text">2. 为什么需要废弃 Windows 32 位 x86 平台上的 Java 支持？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JEP-449%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">13.3.</span> <span class="toc-text">3. JEP 449 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-JEP-449%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">13.4.</span> <span class="toc-text">4. JEP 449 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-JEP-449%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">13.5.</span> <span class="toc-text">5. JEP 449 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-JEP-449%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">13.6.</span> <span class="toc-text">6. JEP 449 的使用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-JEP-449%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">13.7.</span> <span class="toc-text">7. JEP 449 的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-11"><span class="toc-number">13.8.</span> <span class="toc-text">8. 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#451-Prepare-to-Disallow-the-Dynamic-Loading-of-Agents"><span class="toc-number">14.</span> <span class="toc-text">| 451: | Prepare to Disallow the Dynamic Loading of Agents |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%90%86%E7%A6%81%E7%94%A8%E5%87%86%E5%A4%87%EF%BC%88Prepare-to-Disallow-the-Dynamic-Loading-of-Agents%EF%BC%89%EF%BC%9F"><span class="toc-number">14.1.</span> <span class="toc-text">1. 什么是动态加载代理禁用准备（Prepare to Disallow the Dynamic Loading of Agents）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%90%86%E7%A6%81%E7%94%A8%E5%87%86%E5%A4%87%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">2. 为什么需要动态加载代理禁用准备？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%20%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%90%86%E7%A6%81%E7%94%A8%E5%87%86%E5%A4%87%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">14.3.</span> <span class="toc-text">3. 动态加载代理禁用准备的实现原理 </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%20%E4%BF%AE%E6%94%B9%20ClassLoader"><span class="toc-number">14.3.1.</span> <span class="toc-text">3.1 修改 ClassLoader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%20%E4%BF%AE%E6%94%B9%20Instrumentation-API"><span class="toc-number">14.3.2.</span> <span class="toc-text">3.2 修改 Instrumentation API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%20%E6%9B%B4%E6%96%B0%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">14.3.3.</span> <span class="toc-text">3.3 更新安全管理器 </span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%20%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%90%86%E7%A6%81%E7%94%A8%E5%87%86%E5%A4%87%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">14.4.</span> <span class="toc-text">4. 动态加载代理禁用准备的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%20%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%90%86%E7%A6%81%E7%94%A8%E5%87%86%E5%A4%87%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">14.5.</span> <span class="toc-text">5. 动态加载代理禁用准备的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%20%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%90%86%E7%A6%81%E7%94%A8%E5%87%86%E5%A4%87%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">14.6.</span> <span class="toc-text">6. 动态加载代理禁用准备的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%20%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E4%BB%A3%E7%90%86%E7%A6%81%E7%94%A8%E5%87%86%E5%A4%87%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">14.7.</span> <span class="toc-text">7. 动态加载代理禁用准备的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-12"><span class="toc-number">14.8.</span> <span class="toc-text">8. 总结 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#452-Key-Encapsulation-Mechanism-API"><span class="toc-number">15.</span> <span class="toc-text">| 452: | Key Encapsulation Mechanism API |</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%20%E4%BB%80%E4%B9%88%E6%98%AF%20Key-Encapsulation-Mechanism-API"><span class="toc-number">15.1.</span> <span class="toc-text">1. 什么是 Key Encapsulation Mechanism API?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%20%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%20Key-Encapsulation-Mechanism-API"><span class="toc-number">15.2.</span> <span class="toc-text">2. 为什么需要 Key Encapsulation Mechanism API?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Key-Encapsulation-Mechanism-API%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">15.3.</span> <span class="toc-text">3. Key Encapsulation Mechanism API 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Key-Encapsulation-Mechanism-API%20%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">15.4.</span> <span class="toc-text">4. Key Encapsulation Mechanism API 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Key-Encapsulation-Mechanism-API%20%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">15.5.</span> <span class="toc-text">5. Key Encapsulation Mechanism API 的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Key-Encapsulation-Mechanism-API%20%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">15.6.</span> <span class="toc-text">6. Key Encapsulation Mechanism API 的使用示例 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Key-Encapsulation-Mechanism-API%20%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">15.7.</span> <span class="toc-text">7. Key Encapsulation Mechanism API 的使用注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%20%E6%80%BB%E7%BB%93%20-13"><span class="toc-number">15.8.</span> <span class="toc-text">8. 总结 </span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#453-Structured-Concurrency-Preview"><span class="toc-number">16.</span> <span class="toc-text">| 453: | Structured Concurrency (Preview) |</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%EF%BC%88Structured-Concurrency%EF%BC%89%EF%BC%9F"><span class="toc-number">17.</span> <span class="toc-text">什么是结构化并发（Structured Concurrency）？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%EF%BC%9F"><span class="toc-number">18.</span> <span class="toc-text">为什么需要结构化并发？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">19.</span> <span class="toc-text">结构化并发的实现原理 </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">20.</span> <span class="toc-text">结构化并发的优点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">21.</span> <span class="toc-text">结构化并发的缺点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">22.</span> <span class="toc-text">结构化并发的使用示例 </span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">23.</span> <span class="toc-text">结构化并发的使用注意事项</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">24.</span> <span class="toc-text">总结 </span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="../post/nacos-24-guide-to-security-practice-open-permission-certification-configure-the-default-account-password-and-mysql-integration-1fwsrh.html" title="Nacos 2.4 安全实践指南：开启权限认证、配置默认账号密码与 MySQL 集成"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&amp;_r_=9189c559-4895-4a6c-988b-1e1b44ec4c54" onerror="this.onerror=null;this.src='../img/404.jpg'" alt="Nacos 2.4 安全实践指南：开启权限认证、配置默认账号密码与 MySQL 集成"/></a><div class="content"><a class="title" href="../post/nacos-24-guide-to-security-practice-open-permission-certification-configure-the-default-account-password-and-mysql-integration-1fwsrh.html" title="Nacos 2.4 安全实践指南：开启权限认证、配置默认账号密码与 MySQL 集成">Nacos 2.4 安全实践指南：开启权限认证、配置默认账号密码与 MySQL 集成</a><time datetime="2025-01-22T15:03:59.000Z" title="更新于 2025-01-22 15:03:59">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="../today_2023_09.html" title="Today For 2023 年 9 月"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&amp;_r_=ca5b344d-90c6-4861-df03-e0482e54d911" onerror="this.onerror=null;this.src='../img/404.jpg'" alt="Today For 2023 年 9 月"/></a><div class="content"><a class="title" href="../today_2023_09.html" title="Today For 2023 年 9 月">Today For 2023 年 9 月</a><time datetime="2025-01-22T07:04:44.480Z" title="更新于 2025-01-22 07:04:44">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="../c37612c9.html" title="博客优化差不多了"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&amp;_r_=2bfd2b96-ffc2-03f7-1401-7a0670fb38fa" onerror="this.onerror=null;this.src='../img/404.jpg'" alt="博客优化差不多了"/></a><div class="content"><a class="title" href="../c37612c9.html" title="博客优化差不多了">博客优化差不多了</a><time datetime="2025-01-22T07:04:44.480Z" title="更新于 2025-01-22 07:04:44">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="../cb2b755d.html" title="老婆七夕快乐"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&amp;_r_=b874a280-f7c7-8011-f05a-584874a20da5" onerror="this.onerror=null;this.src='../img/404.jpg'" alt="老婆七夕快乐"/></a><div class="content"><a class="title" href="../cb2b755d.html" title="老婆七夕快乐">老婆七夕快乐</a><time datetime="2025-01-22T07:04:44.480Z" title="更新于 2025-01-22 07:04:44">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="../71f4c8f5.html" title="聊聊近况，一个字【累】"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img.xjh.me/random_img.php?return=302&amp;_r_=6fcd8cc5-a019-06fd-d335-b32efb528c4c" onerror="this.onerror=null;this.src='../img/404.jpg'" alt="聊聊近况，一个字【累】"/></a><div class="content"><a class="title" href="../71f4c8f5.html" title="聊聊近况，一个字【累】">聊聊近况，一个字【累】</a><time datetime="2025-01-22T07:04:44.480Z" title="更新于 2025-01-22 07:04:44">2025-01-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><div id="runtimeTextTip"></div></div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://beian.miit.gov.cn/"><span>苏ICP备2024066768号-1</span></a></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2025 By <a class="footer-bar-link" href="index.html" title="程序员朱永胜" target="_blank">程序员朱永胜</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="archives/" title="archive"><div class="headline">文章</div><div class="length-num">1221</div></a><a href="tags/" title="tag"><div class="headline">标签</div><div class="length-num">901</div></a><a href="categories/" title="category"><div class="headline">分类</div><div class="length-num">14</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" rel="external nofollow noreferrer" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://blog.zysicyj.top/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2748ef34.jpg" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">写作软件</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://editor.runjs.cool/post?id=demo" title="Mdx"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4296739868700.png" alt="Mdx"/><span class="back-menu-item-text">Mdx</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://openwrite.cn/" title="OpenWrite"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://openwrite.cn/logo.png" alt="OpenWrite"/><span class="back-menu-item-text">OpenWrite</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jetbrains.com/zh-cn/writerside/" title="WriteSide"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBwgHBgkIBwgKCgkLDRYPDQwMDRsUFRAWIB0iIiAdHx8kKDQsJCYxJx8fLT0tMTU3Ojo6Iys/RD84QzQ5OjcBCgoKDQwNGg8PGjclHyU3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3N//AABEIAMAAzAMBEQACEQEDEQH/xAAcAAEBAAIDAQEAAAAAAAAAAAAAAQIHBAUGCAP/xABEEAACAAMBCQ8CAggHAAAAAAAAAQIDBAUGBxE1UVR0k7ISFBUWFzE0NlVzkaKxwtIh0UFhEyQlRFKUs+EiJjIzQ1Nx/8QAGwEBAAMBAQEBAAAAAAAAAAAAAAECAwYFBAf/xAA0EQEBAAADBAcFCQEBAQAAAAAAAQIDcQQRM1IFExQVUaGxITJBkdEGEhYiIyQxNMFhckL/2gAMAwEAAhEDEQA/AN4gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAjeAF9jgu17OhiihirpCiTaacxfRondX0TZM+zfMF+ScMWbn9PrENyex7RyU4Ys3P6fWIbjse0clOGLNz+n1iG47HtHJThizc/p9YhuOx7RyU4Ys3P6fWIbjse0clOGLNz+n1iG47HtHJThizc/p9Yhup2PaOSnDFm5/T6xDdfA7HtHJThmzM/p9Yifu3wOx7RyU4ZsztCn1iH3MXgjsmfyU4Zs3P6fWIfcxeB2TP5KcM2Zn9PrEPuYvBHZM/kpw1ZnaFPrET1ePwOy5/JThqzO0KfWIdVj8DsufyVOG7L7Qp9YieqzPCnZs7lpw3ZfaFPrEOpzOWnZs7lorasxtQq0KdtvAl+kXOOpzOWo7PnctdgjNioAAAAAAI/wA0jaiXC1ofRdLnf1Ij6J/Efo2zX9DL/84fSONgWREt95gWRA3mBZEDeYFkQN5gWRA3mBZEDeYFkRMRvTAsiLyItYtLIi8ilqNLIjSRW1GlkReRG9GlkRrIrvYtLIi8itqYFkReRTfUwLIjSRG9MCyIvFbX60SW/6T6L/AH5e0icXuYtL6M8y/kxaX0b9hOVcQoAAAAAAJF+AGkrUxtaGlzv6kR9E/iP0bZuBl/8AnD6RxiW4AAAAAiENJFaxZpIrUZeRWoXkVRmkiKxwmkilQvIrvQvIhDSRVi2XkUfrRdPpO/l7SJxT8t0vozzPcul9G/kck4tQAAAAAARgeQn3A0VRUTp8dbVqKdMimNLc4E4m2/w/M06y7nu5fT2fl4JgmCeySfH4exhyd2fn1Z5PiOsq/wCIs/knn9Tk7s/PqzyfEdZT8RZ/JPP6nJ3Z+fVnk+I6yn4iz+Sef1OTuz8+rPJ8R1lPxFn8k8/qcndBn1Z5PiOsp+Ic/knn9Tk8oM+rPJ8Setvgj8Q5/JPP6o73VA/36s8nxJ6++B+IM/knn9Tk6s/PqzyfEt2i+ER3/nck8/qnJ1Z+f1nk+JPasXhEd/Z3JPP6jvcWe/3+t8nxLdsxeEO/s7knn9U5N7Pz+t8nxJ7bj8Ijv3O5J5/VOTez8/rfJ8S3b8c/+Z5/VHfmdyTz+pybWf2hW+T4k944+Wef1R35nck8/qnJrZ+f1vk+JM6SzOWef1R33nck8/q8hdhYcmwK+RTSJ02bDHJ/SOKbgw4d01+B6Wx5+LPwW2btHpbFteLacFxYpJ7fho6Bn3SPsftQYwpNIl7SJxz8l0vozzL+S6X0b+hONji4yJSAAAAAAAAAAAAAAAAAAAAAAAAGrb6n0tyk0X3s93orhYtXQ9EcHFq8UevI9S1+1BjCk0iXtIY5+S6X0Z5l/JdL6N/wnFONjIlIAAAfnMnS5WBzY4YE+bdRYMIThw4sXuzew35TZxJ1iC/U5nLfkb8ps4k6xA6nM5b8jflNnEnWIHU5nLfkb8ps4k6xA6nM5b8jflNnEnWIHU5nLfkb8ps4k6xA6nM5b8jflLnMnWIbqdTmct+RvylzmTrETup1WZy35G/KXOZOsQ3U6nM5b8jflLnMnWIbr4HVZnLfkb8pc5k6xD7t8DqszlpvylzmTrEPu4vA6rHy035S5zJ1iH3cXgdVj8Kb9pc5k6xE/cxeB1WPwoqymiiUMM+U2+ZKNfUfdxeCOrxz4V+5VQA1ZfWx7SaJ72e/0RN+Vi1e/wBE8HFq8UexI9S1+1A/2hSaRL2kMc/Ji0vozzL+S6X0fQK5ziHHqEgAAB4i+ev1Kz+/i2Wa5fxdF9neLmaT1a+wGjqjAAwAMAAmIRl5Eb2JeRXehpIrvRl5FUNJhVqPBkReYVd7FmkitqF5FajSyGkitrsrmMHGSzVg/wCdejM9pn6GK/8AHy7Zf2+PRvFcxzTjwDVl9bHtJonvZ0XQ8/Rxave6Jv6OLV4k9iR6e9+1C/2hSaRL2kMyfp4tL6M8y/kxaX0fQS5zhXJKAAAAPEXz+hWf38Wya5fxdF9neJmaT1a/NHVgAATIhMP0LyK2scJpIrvQvIrvQvIqxwmkiN6NmkilqF5FajLyKozSRFrFsvIra7K5h/5kszSF6MptM/Qx6Pl2y/t8ejeRyzkADVd9fHtJovvZ0nQvtyMWr3eiuFi1eJbPakelX7UGMKTSJe0hmT9PFpfRnmX9PFpfR9Bo4FyigAAADxF8/oVn9/FsmuX8XRfZ3iZmk9WvzR1YAJkQmEvIraxwmkitqF5Fd6F5FWLZpIhGzSRS1C8itqMvIqhpIi1i2XkUtYtmkiHZ3L9ZbM0hejM9qn6GPR821/18ejeZybkQDVV9jHtJovvZ03Qk/Qxa/R7nRfCxavEM9uR6O9+9n4xpNIl7SK5vDxaX0UzPcxaV9CI4ByqgAAADxF8/oVn9/FsmuX8XRfZ3iZmk9WvzR1YTIhC8itY4S8itQ0kVtQvIqxZpIhGzSRS1C8iu9C8iqGkiKxbLyKWsWzSRCGkitdncv1lsvSF6Mx2qft8ej5tsv7fHo3oci5MA1VfZx7R6L72dP0FwMWv+R7fRnCxavEHtvRfvZ+MaPSJe0imbw8Wl9Fcz3MWlfQiOAcqoAAAA8RfP6FZ/fxbJrl/F0X2d4mZpPVr81jqkLyK1iy8itRmkitQvIqxZpIhGzSRSoXkV3oXkQhpIrWLLyKVizSRCM0kVqMvIrXZ3L9ZbM0hejMtrn7bHo+ba+Bj0b1ONcqAaqvs49o9E97Oo6C4GLX/I9rozhYtXhz2npORZ+MaPSJe0imbw8Wl9Fcz3MWlfQiOAcqoAAAA8RfP6FZ/fxbJrlfzXRfZ3iZmk9Wvj6JHUViy8itRmkitQvIqxZpIhGzSRSoXkV3oXkQhpIrWLLyKVizSRCM0kVqMvIrULyK12dy3WazNIXozLbJ+2zNHzbXwMejexxTlwDVV9nHtHonvZ1HQXAxa/5HtdGcLFq8Oe09JyLPxjR6RL2kUzeHi0vorme5i0r6ERwDlVAAADA8RfQ6FZ/fxbJtk/zXQ/Z7iZmk9WvGfVI6eozSRWoy8iqM0kVtY4TSRWoXkVqF5EIaSKsW0XkUYs0kQhpIrajLyK1C8itRs0kVdncr1msvSF6Mw22ftsej5tq4GPRvc4hzIBqq+zj2j0T3s6joLgYtf8j2ujOFi1eHPaek5Fn4xo9Il7SKZvDxaX0VzPcxaV9CI4ByqgAAADw19LoNn9/Fss+jZ/5roPs/xMzSerXrPskdNajLyKoaSItY4TSRSoXkVtQvIqhpIjexbReRRizSRCGkitqF5FbULyK2o2aSK72JeRWu0uV6zWXpC9GfPt39bHow2ng49G+DhnMgGqr7OPaPRPezqOguBi1/yPa6M4WLV4c9p6TkWfjGj0iXtIpm8PFpfRXM9zFpX0IjgHKqAAAAPDX0ug2f38Wyz6tmntr3+gOJmaT1a8Z9sjpWOE0kVtTCaSK2oXkRaheRW1GaSK72LZeRTexbNJEIaSK2oXkVtQvIrajZpIraxwl5FbQlDtLles1l6QvRnzbd/Wx6MNp4GPRvg4ZzQBqm+zj6j0X3s6joLgYtf8j2ujOFi1eIPaek5Fn4xo9Il7SKZvDxaX0VzPcxaV9CI4ByqgAAADwt9P6UNn9/Fss+vZJvte/wBAcTM0nq13hPQkdHamEvIraxcSyo1kQjiWVF5FajihyovIj2o41lXiXkVYuKH+JeJpMNU9rHdQ/wAS8TSRHtTdQ5V4l5Ffam6hfM14mkw1WjZeRS1iy8itoShAO1uV6zWXpC9GfNt39bHow2ngY9G+DhnNAGqb7WPqPRfezqOguBi1/wAj2+jOFi1eIPaei5Fn4xo9Il7SKZvDxaX0VzPcxaV9CI4ByqgAABgeEvqP9Ss7v4tln27F7bdHvdA+/maT1a7wnpSOitYxP/Cy8h8W6LGsqzorJoooqCliiip5bbcmFtvcr8jw8zMxzHfa4nOz82ZmKTFf5vxczgmzez6TUQ/Yr1uZzX5su0Z3NfmcE2b2fSaiH7DrczmvzOvzea/M4Is3s+k1EP2HXZnNfmdfm81+ZwRZnZ9JqIfsOuzea/M67N5r8zgizez6TUQ/Ynr83mvzR12bzX5nBFm9n0moh+w6/N5r8zrszmvzdFdxZtDJuVtCbJo6aXMhl4YYoJUKa+uVH29H52bi2nBLivzfVsebjufhltadOv3PftCUIAA7W5XrNZekL0Z823f1sejDaeBj0b4OGc0AapvtY+o9F97Oo6C4GLX/ACPb6M4WLV4g9p6LkWfjGj0iXtIpm8PFpfRXM9zFpX0IjgHKqAAAR8wHhL6vQbN7+LYZ92wfzi0e70F7+ZpPVrtnqSOitYxf6X/4aSI3+1vWxMT0Ojy9lHO5vExa1w2fxcWtc0zZAAAAAAefu+6o2l3R9/Rn9vBq+rYv7GDVpM7R0SEAAA7W5XrNZekL0Z823f1sejDaeBj0b4OGc0AapvtY+o9F97Oo6C4GLX/I9vozhYtXiD2nouRZ+MaPSJe0imbw8Wl9Fcz3MWlfQiOAcqoAABHzAeEvrdBs3SIthnodHe9i0/17nQfv49I10z1ZHQ2sYsOBr8jTDPajf8W0rMu3sOns6lkTaiYo5cmCCJKTE/qoUjxcewZ+LFbI5fN6N2nFmYrJ8b8XJ4/XP51N1EX2I7t2nw82fde0+HnE4/XP51N1EX2J7s2nw84juzafDzhx/uezqbqI/sT3XtXh5w7s2nw84nKBc9nU3URfYnuravDzh3btPh5w5QLns6m6iP7E90bXy+cR3dtHh5w5Qbns6m/y8f2J7n2vl84ju/aPDzjqLq7srFtO5+so6SfMinTYMEKcmJLnys+vYejNpydow48c9k/632bYs7LzZjxT2RrM6R7HxAAADtbles1l6QvRnzbd/Wx6MNp4GPRvg4ZzQB4G725m1LdtSnqLPlyooJcjcRbuZufrumz3Oi9vyNmysWHM377fD/j0ti2rKycFw4/F5rk+ui/6Kb+Y/sen3xsnjfk+3vDZ/G/J+tLcFdBKq6ebFJp1DBNgjeCen9FEnkKZnS+y3BZLf48FcXSGRcNk3/w25CclHhMiQAAR8wHhL6/QbN0iLYZ6PRvvYtP9e50J7+PSerXJ7Ej36xZeRSsTSRCGkitRl5FaheRRGzSRDEvIqEoQAAAAAO1uV6zWXpC9GfNt39bHow2ngY9G+DhnNAEwLIBQAAAAAAR8wHhL6/QrN0iLYZ6fRnvYtHtdC+/j0nq1uz2ZHvVizSRCM0kVqMvIrULyK1GzSRViXkVCUAAAAAAAO0uV6zWXpC9GfNt39bM0YbVwMejfBwzmgAAAAAAAAAfMB19q2PQ2tBLgtCQp0MuLdQp/g8GA0ys7HlXfgu7e2ydozMm25d3b3XcTLA7Og8Wb9u2jmb947TzJxLuf7Og8WT2/aOY7w2nnOJVz/Z0Hiye8Npn/ANI7w2nmOJVz/ZsHix3jtXOdv2jmTiTc92bL8WT3ltXOjt+0cy8SbnuzZfiye89r50du2jmTiTc92ZL8WT3ptfOdu2jmOJFzvZkvxY702vnO3bRzHEi53syX4sd6bXznbto5jiRc72ZL8WO9Nr5zt20cxxIud7Ml+LHem18527aOY4kXO9mS/FjvTa+c7dtHMcSLnezJfix3ptfOdu2jmOJFzvZkvxY702vnO3bRzP0prkLCpKmXUU9nwQTpcW6giTf0ZTH0jtOPDcOLF7KjFtefin3bid8uZHxPmUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9k=" alt="WriteSide"/><span class="back-menu-item-text">WriteSide</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">开发工具</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jetbrains.com/zh-cn/idea/" title="idea"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4576710485000.png" alt="idea"/><span class="back-menu-item-text">idea</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jetbrains.com/zh-cn/datagrip/" title="DataGrip"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4604435065400.png" alt="DataGrip"/><span class="back-menu-item-text">DataGrip</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4663369180700.png" title="WebStorm"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4604435065400.png" alt="WebStorm"/><span class="back-menu-item-text">WebStorm</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" title="微信开发者工具"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4743988475500.png" alt="微信开发者工具"/><span class="back-menu-item-text">微信开发者工具</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" title="HBuilder"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.dcloud.io/hbuilderx.html" alt="HBuilder"/><span class="back-menu-item-text">HBuilder</span></a><a class="back-menu-item" target="_blank" rel="noopener external nofollow noreferrer" href="https://mobaxterm.mobatek.net/" title="MobaXterm"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="http://blog-1253652709.cos.ap-guangzhou.myqcloud.com/pasteimageintomarkdown/2024-07-16/4849682167700.png" alt="MobaXterm"/><span class="back-menu-item-text">MobaXterm</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="index.html"><i class="fas fa-home faa-tada"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-link faa-tada"></i><span> 目录</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="fas fa-archive faa-tada"></i><span> 时间轴</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="fas fa-folder-open faa-tada"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-list faa-tada"></i><span> 清单</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/movies/"><i class="fas fa-video faa-tada"></i><span> 电影</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/books/"><i class="fas fa-book faa-tada"></i><span> 阅读</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/songs/"><i class="fas fa-music faa-tada"></i><span> 音乐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="fa-brands fa-bilibili faa-tada"></i><span> 追番</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cinemas/"><i class="fa-brands fa-bilibili faa-tada"></i><span> 追剧</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="fas fa-link faa-tada"></i><span> 友链</span></a></li></ul></div><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/gallery/"><i class="fas fa-solid fa-image faa-tada"></i><span> 相册集</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/love/static/index.html"><i class="fas fa-heart faa-tada"></i><span> Love</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="fa-solid fa-user faa-tada"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="fa-solid  fa-comment faa-tada"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="js/utils.js"></script><script src="js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("07/01/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 程序员朱永胜 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("07/01/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="js/search/local-search.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/music/"]):not([href="/no-pjax/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>